---
title: "Manuscript results: Forecasting influenza using ARIMA and ARIMAX"
author: "Victor Felix"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  pdf_document: default
---

This document has the results that we present in our manuscript draft. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading libraries.

```{r}
library("tidyr")
library("MMWRweek")
library("data.table")
library("caret")
library("purrr")
library("dplyr")
library("tseries")
library("gtools")
library("forecast")
library("scoringutils")
library("covidHubUtils")
library("parallel")
library("future")#https://cran.r-project.org/web/packages/future/vignettes/future-4-issues.html
library("listenv")
library("epitools")
library("ggplot2")
library("sf")
library("forcats")
library("ggplot2")
library("sf")
library("dplyr")
library("scales")  # For `breaks_extended`
library("ggplot2")
library("broom")
library("fields")
library("ggpubr")
library("patchwork")

```

Loading the results of each model and the shapefiles of the maps.

```{r}

load("NHSH_hospitalizations_seed_nolog_correct/ES_ARIMA/ARIMA_MODELS_influenza_hospitalization_nolog.Rdata")
load("NHSH_hospitalizations_seed_nolog_correct/ES_ADJACENT/ADJACENT_MODELS_influenza_hospitalization_nolog.Rdata")
load("NHSH_hospitalizations_seed_nolog_correct/ES_EPIWEEK/EPIWEEK_MODELS_influenza_hospitalization_nolog.Rdata")
load("NHSH_hospitalizations_seed_nolog_correct/ES_TEMPERATURE/TEMPERATURE_MODELS_influenza_hospitalization_nolog.Rdata")
load("NHSH_hospitalizations_seed_nolog_correct/ES_AVERAGE/AVERAGE_MODELS_influenza_hospitalization_nolog.Rdata")

states <- read_sf("NHSH_hospitalizations_seed_nolog_correct/shapefiles/cb_2018_us_state_500k.shp")

states <- states %>%
  rename(STATE = NAME)

```

------------
1 Week ahead
------------
```{r}

# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK1$epiweek <- MMWRweek(AUTO_ARIMA_WEEK1$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK1$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK1$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK1$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK1$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK1$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK1$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES27_ARIMA_WEEK1$epiweek <- MMWRweek(ES27_ARIMA_WEEK1$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK1$epiweek <- MMWRweek(ES27_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK1$epiweek <- MMWRweek(ES27_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES64_ARIMA_WEEK1$epiweek <- MMWRweek(ES64_ARIMA_WEEK1$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK1$epiweek <- MMWRweek(ES64_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK1$epiweek <- MMWRweek(ES64_AVERAGE_WEEK1$target_end_date)$MMWRweek

# Dataframe that will be analysed for 1 Week Ahead
df_W1_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK1$State,
  Julian_date = AUTO_ARIMA_WEEK1$target_end_date,
  epiweek = AUTO_ARIMA_WEEK1$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK1$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK1$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK1$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK1$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK1$WIS,
  
  ES27_AR=ES27_ARIMA_WEEK1$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK1$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK1$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK1$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK1$WIS,
  
  ES64_AR=ES64_ARIMA_WEEK1$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK1$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK1$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK1$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK1$WIS
)

head(df_W1_NoLg)
```

------------
2 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK2$epiweek <- MMWRweek(AUTO_ARIMA_WEEK2$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK2$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK2$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK2$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK2$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK2$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK2$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES27_ARIMA_WEEK2$epiweek <- MMWRweek(ES27_ARIMA_WEEK2$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK2$epiweek <- MMWRweek(ES27_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK2$epiweek <- MMWRweek(ES27_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES64_ARIMA_WEEK2$epiweek <- MMWRweek(ES64_ARIMA_WEEK2$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK2$epiweek <- MMWRweek(ES64_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK2$epiweek <- MMWRweek(ES64_AVERAGE_WEEK2$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Weeks Ahead
df_W2_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK2$State,
  Julian_date = AUTO_ARIMA_WEEK2$target_end_date,
  epiweek = AUTO_ARIMA_WEEK2$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK2$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK2$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK2$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK2$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK2$WIS,
  
  ES27_AR=ES27_ARIMA_WEEK2$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK2$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK2$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK2$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK2$WIS,
  
  ES64_AR=ES64_ARIMA_WEEK2$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK2$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK2$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK2$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK2$WIS
  
)

head(df_W2_NoLg)
```

-------------
3 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK3$epiweek <- MMWRweek(AUTO_ARIMA_WEEK3$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK3$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK3$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK3$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK3$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK3$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK3$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES27_ARIMA_WEEK3$epiweek <- MMWRweek(ES27_ARIMA_WEEK3$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK3$epiweek <- MMWRweek(ES27_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK3$epiweek <- MMWRweek(ES27_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES64_ARIMA_WEEK3$epiweek <- MMWRweek(ES64_ARIMA_WEEK3$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK3$epiweek <- MMWRweek(ES64_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK3$epiweek <- MMWRweek(ES64_AVERAGE_WEEK3$target_end_date)$MMWRweek


# Dataframe that will be analysed for 3 Weeks Ahead
df_W3_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK3$State,
  Julian_date = AUTO_ARIMA_WEEK3$target_end_date,
  epiweek = AUTO_ARIMA_WEEK3$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK3$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK3$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK3$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK3$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK3$WIS,
    
  ES27_AR=ES27_ARIMA_WEEK3$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK3$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK3$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK3$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK3$WIS,
    
  ES64_AR=ES64_ARIMA_WEEK3$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK3$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK3$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK3$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK3$WIS
)

head(df_W3_NoLg)
```

-------------
4 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK4$epiweek <- MMWRweek(AUTO_ARIMA_WEEK4$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK4$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK4$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK4$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK4$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK4$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK4$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES27_ARIMA_WEEK4$epiweek <- MMWRweek(ES27_ARIMA_WEEK4$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK4$epiweek <- MMWRweek(ES27_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK4$epiweek <- MMWRweek(ES27_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES64_ARIMA_WEEK4$epiweek <- MMWRweek(ES64_ARIMA_WEEK4$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK4$epiweek <- MMWRweek(ES64_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK4$epiweek <- MMWRweek(ES64_AVERAGE_WEEK4$target_end_date)$MMWRweek

# Dataframe that will be analysed for 4 Weeks Ahead
df_W4_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK4$State,
  Julian_date = AUTO_ARIMA_WEEK4$target_end_date,
  epiweek = AUTO_ARIMA_WEEK4$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK4$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK4$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK4$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK4$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK4$WIS, 
  
  ES27_AR=ES27_ARIMA_WEEK4$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK4$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK4$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK4$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK4$WIS,  
  
  ES64_AR=ES64_ARIMA_WEEK4$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK4$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK4$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK4$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK4$WIS  
)

head(df_W4_NoLg)
```

Filter only the flu season

```{r}
# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W1_NoLg <- df_W1_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W1_NoLg)


# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W2_NoLg <- df_W2_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W2_NoLg)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W3_NoLg <- df_W3_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W3_NoLg)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W4_NoLg <- df_W4_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W4_NoLg)
```

Example of influenza hospitalizations forecasts and 95% confidence interval.

```{r}

# Create a data frame with forecasts for plotting
forecast_df <- data.frame(
  Week = factor(1:4, labels = paste0("Week ", 1:4)),  # Label weeks
  Value = c(AUTO_ARIMA_WEEK1_list[[1]]$forecasts[5], 
            AUTO_ARIMA_WEEK2_list[[1]]$forecasts[5], 
            AUTO_ARIMA_WEEK3_list[[1]]$forecasts[5], 
            AUTO_ARIMA_WEEK4_list[[1]]$forecasts[5]),
  Lower = c(AUTO_ARIMA_WEEK1_list[[1]][["0.025"]][5], 
            AUTO_ARIMA_WEEK2_list[[1]][["0.025"]][5], 
            AUTO_ARIMA_WEEK3_list[[1]][["0.025"]][5], 
            AUTO_ARIMA_WEEK4_list[[1]][["0.025"]][5]),
  Upper = c(AUTO_ARIMA_WEEK1_list[[1]][["0.975"]][5], 
            AUTO_ARIMA_WEEK2_list[[1]][["0.975"]][5], 
            AUTO_ARIMA_WEEK3_list[[1]][["0.975"]][5], 
            AUTO_ARIMA_WEEK4_list[[1]][["0.975"]][5])
)


# Plotting forecasts and ribbon
plt00 <- ggplot(forecast_df, aes(x = Week, y = Value, group = 1)) +
  geom_line(color = "black", size = 1) +          # Line connecting forecast values
  geom_point(color = "black", size = 3) +         # Points for each forecast value
  geom_ribbon(aes(ymin = Lower, ymax = Upper),   # Ribbon for confidence intervals
              fill = "gray", alpha = 0.25) +
  labs(title = "Figure 1: Example of probabilistic forecasts",
       subtitle = "The gray ribbon indicates the 95% confidence interval",
       x = "Target Weeks",
       y = "Forecast Values") +
  theme_minimal() +
  theme(plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 14))

plt00

ggsave(plt00, height = 4, width =7, filename="Fig1.jpg") 
```

Weighted interval scores for each state and each target week.

```{r}
library(dplyr)
library(ggplot2)

# Combine all datasets and add a column to identify them
df_combined_ <- bind_rows(
  df_W1_NoLg %>% mutate(Dataset = "1 week ahead"),
  df_W2_NoLg %>% mutate(Dataset = "2 weeks ahead"),
  df_W3_NoLg %>% mutate(Dataset = "3 weeks ahead"),
  df_W4_NoLg %>% mutate(Dataset = "4 weeks ahead")
) %>%
  select(STATE, epiweek, AUTO_AR, Dataset, Julian_date) %>%
  rename(WIS = AUTO_AR)  # Rename for consistency

# Define the epiweek values to highlight
highlight_weeks <- c(21, 41)

# Get corresponding Julian dates for these epiweeks
highlight_dates <- df_combined_ %>%
  filter(epiweek %in% highlight_weeks) %>%
  select(epiweek, Julian_date) %>%
  distinct()

# Plot
plt0 <- ggplot(df_combined_, aes(x = Julian_date, y = WIS, group = STATE)) + 
  geom_vline(data = highlight_dates, aes(xintercept = Julian_date), color = "red", linetype = "dashed", size = 1) +  
  geom_line(color = "black", size = 0.1) +  
  facet_wrap(~ Dataset, ncol = 2, scales = "free_y") +  
  theme_minimal() +  
  labs(title = "Baseline model WIS for 48 states on the contiguous U.S.",#,
       subtitle = "Weeks between the dashed red lines are outside of the influenza season",
       x = "", 
       y = "WIS") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 16, face = "bold"),
        legend.position = "none") +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %y"
  ) # Format x-axis to show months and set monthly breaks

# Print the plot
plt0

ggsave(plt0, height = 5, width = 8, filename="Fig2.jpg")  
```

Computing mean weighted interval score for all target week for each model.

```{r}

# Define the function
calculate_mean_wis <- function(data) {
  data %>%
    group_by(STATE) %>%
    summarize(
      AUTO_AR = mean(AUTO_AR, na.rm = TRUE),
      AUTO_ADJ = mean(AUTO_ADJ, na.rm = TRUE),
      AUTO_EPI = mean(AUTO_EPI, na.rm = TRUE),
      AUTO_TMP = mean(AUTO_TEMP, na.rm = TRUE),
      AUTO_AVG = mean(AUTO_AVG, na.rm = TRUE),
      
      ES27_AR = mean(ES27_AR, na.rm = TRUE),
      ES27_ADJ = mean(ES27_ADJ, na.rm = TRUE),
      ES27_EPI = mean(ES27_EPI, na.rm = TRUE),
      ES27_TMP = mean(ES27_TEMP, na.rm = TRUE),
      ES27_AVG = mean(ES27_AVG, na.rm = TRUE),
      
      ES64_AR = mean(ES64_AR, na.rm = TRUE),
      ES64_ADJ = mean(ES64_ADJ, na.rm = TRUE),
      ES64_EPI = mean(ES64_EPI, na.rm = TRUE),
      ES64_TMP = mean(ES64_TEMP, na.rm = TRUE),
      ES64_AVG = mean(ES64_AVG, na.rm = TRUE)
    )
}

# Now you can use the function with any dataframe
W1_NoLg <- calculate_mean_wis(filtered_df_W1_NoLg)
W2_NoLg <- calculate_mean_wis(filtered_df_W2_NoLg)
W3_NoLg <- calculate_mean_wis(filtered_df_W3_NoLg)
W4_NoLg <- calculate_mean_wis(filtered_df_W4_NoLg)

# Display the resulting dataframe
head(W1_NoLg)
head(W2_NoLg)
head(W3_NoLg)
head(W4_NoLg)

```

Boxplots of the mean(WIS) by each state. 

```{r}
# Combine the data into one data frame
combined_data <- data.frame(
  week = rep(c("W1", "W2", "W3", "W4"), each = 48 * 15),
  
  Models = rep(c("AUTO_AR", "ES27_AR", "ES64_AR", "AUTO_ADJ", "ES27_ADJ", "ES64_ADJ", "AUTO_TMP", "ES27_TMP", "ES64_TMP", "AUTO_EPI", "ES27_EPI", "ES64_EPI","AUTO_AVG", "ES27_AVG", "ES64_AVG"), each=48, times = 4),
  
  value = c(W1_NoLg$AUTO_AR, W1_NoLg$ES27_AR, W1_NoLg$ES64_AR, 
            W1_NoLg$AUTO_ADJ, W1_NoLg$ES27_ADJ, W1_NoLg$ES64_ADJ, 
            W1_NoLg$AUTO_TMP, W1_NoLg$ES27_TMP, W1_NoLg$ES64_TMP, 
            W1_NoLg$AUTO_EPI, W1_NoLg$ES27_EPI, W1_NoLg$ES64_EPI,
            W1_NoLg$AUTO_AVG, W1_NoLg$ES27_AVG, W1_NoLg$ES64_AVG,
              
            W2_NoLg$AUTO_AR, W2_NoLg$ES27_AR, W2_NoLg$ES64_AR, 
            W2_NoLg$AUTO_ADJ, W2_NoLg$ES27_ADJ, W2_NoLg$ES64_ADJ, 
            W2_NoLg$AUTO_TMP, W2_NoLg$ES27_TMP, W2_NoLg$ES64_TMP, 
            W2_NoLg$AUTO_EPI, W2_NoLg$ES27_EPI, W2_NoLg$ES64_EPI,
            W2_NoLg$AUTO_AVG, W2_NoLg$ES27_AVG, W2_NoLg$ES64_AVG,
            
            W3_NoLg$AUTO_AR, W3_NoLg$ES27_AR, W3_NoLg$ES64_AR,
            W3_NoLg$AUTO_ADJ, W3_NoLg$ES27_ADJ, W3_NoLg$ES64_ADJ, 
            W3_NoLg$AUTO_TMP, W3_NoLg$ES27_TMP, W3_NoLg$ES64_TMP, 
            W3_NoLg$AUTO_EPI, W3_NoLg$ES27_EPI, W3_NoLg$ES64_EPI,
            W3_NoLg$AUTO_AVG, W3_NoLg$ES27_AVG, W3_NoLg$ES64_AVG,
            
            W4_NoLg$AUTO_AR, W4_NoLg$ES27_AR, W4_NoLg$ES64_AR,
            W4_NoLg$AUTO_ADJ, W4_NoLg$ES27_ADJ, W4_NoLg$ES64_ADJ, 
            W4_NoLg$AUTO_TMP, W4_NoLg$ES27_TMP, W4_NoLg$ES64_TMP, 
            W4_NoLg$AUTO_EPI, W4_NoLg$ES27_EPI, W4_NoLg$ES64_EPI,
            W4_NoLg$AUTO_AVG, W4_NoLg$ES27_AVG, W4_NoLg$ES64_AVG
            )
)

# Create a new column for categories
combined_data <- combined_data %>%
  mutate(category = case_when(
    grepl("AR", Models) ~ "AR",
    grepl("EPI", Models) ~ "EPI",
    grepl("TMP", Models) ~ "TMP",
    grepl("ADJ", Models) ~ "ADJ",
    grepl("AVG", Models) ~ "AVG",
  ))

# Define color ramps for each category
colors_ar <- c("#a6cee3","#226e83", "#08306b")
colors_adj <- c("#fb9a99","red3", "#a11c3e")
colors_epi <- c("#cab2d6", "purple2", "#5e2b7b")
colors_tmp <- c("lightgreen","green3","#319045")
colors_avg <- c("orange","orange2", "orange3")

# Create a custom color mapping for each variable
custom_colors <- c(
  "AUTO_AR" = colors_ar[1], "ES27_AR" = colors_ar[2], "ES64_AR" = colors_ar[3],
  "AUTO_EPI" = colors_epi[1], "ES27_EPI" = colors_epi[2], "ES64_EPI" = colors_epi[3],
  "AUTO_TMP" = colors_tmp[1], "ES27_TMP" = colors_tmp[2], "ES64_TMP" = colors_tmp[3],
  "AUTO_ADJ" = colors_adj[1], "ES27_ADJ" = colors_adj[2], "ES64_ADJ" = colors_adj[3],
  "AUTO_AVG" = colors_avg[1], "ES27_AVG" = colors_avg[2], "ES64_AVG" = colors_avg[3]
)

  # Create the box plot with additional facet for categories
plt1<-  ggplot(combined_data, aes(x = week, y = value, fill = Models)) +
    geom_boxplot(color = "black") +
    scale_fill_manual(values = custom_colors) +
    facet_wrap(category ~ Models , nrow = 5) +
    labs(
      title = "A) Models without log-back transformations",
      x = "",
      y = "Mean Weighted Interval Score (WIS)"
    ) +
  scale_y_continuous(limits = c(0, 650)) +  # Set y-axis range
    theme_minimal()+
  theme(legend.position = "none")
plt1
#ggsave(plt1, height = 12, width = 8, filename="fig1A.jpg")  
```

Loading model with log-back transformations.

```{r}
load("NHSH_hospitalizations_seed/ES_ARIMA/ARIMA_MODELS_influenza_hospitalization.Rdata")
load("NHSH_hospitalizations_seed/ES_ADJACENT/ADJACENT_MODELS_influenza_hospitalization.Rdata")
load("NHSH_hospitalizations_seed/ES_EPIWEEK/EPIWEEK_MODELS_influenza_hospitalization.Rdata")
load("NHSH_hospitalizations_seed/ES_TEMPERATURE/TEMPERATURE_MODELS_influenza_hospitalization.Rdata")
load("NHSH_hospitalizations_seed/ES_AVERAGE/AVERAGE_MODELS_influenza_hospitalization.Rdata")
```

------------
1 Week ahead
------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK1$epiweek <- MMWRweek(AUTO_ARIMA_WEEK1$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK1$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK1$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK1$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK1$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK1$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK1$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES27_ARIMA_WEEK1$epiweek <- MMWRweek(ES27_ARIMA_WEEK1$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK1$epiweek <- MMWRweek(ES27_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK1$epiweek <- MMWRweek(ES27_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES64_ARIMA_WEEK1$epiweek <- MMWRweek(ES64_ARIMA_WEEK1$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK1$epiweek <- MMWRweek(ES64_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK1$epiweek <- MMWRweek(ES64_AVERAGE_WEEK1$target_end_date)$MMWRweek

# Dataframe that will be analysed for 1 Week Ahead
df_W1 <- data.frame(
  STATE = AUTO_ARIMA_WEEK1$State,
  Julian_date = AUTO_ARIMA_WEEK1$target_end_date,
  epiweek = AUTO_ARIMA_WEEK1$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK1$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK1$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK1$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK1$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK1$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK1$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK1$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK1$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK1$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK1$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK1$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK1$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK1$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK1$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK1$WIS  
)

head(df_W1)
```

------------
2 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK2$epiweek <- MMWRweek(AUTO_ARIMA_WEEK2$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK2$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK2$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK2$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK2$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK2$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK2$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES27_ARIMA_WEEK2$epiweek <- MMWRweek(ES27_ARIMA_WEEK2$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK2$epiweek <- MMWRweek(ES27_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK2$epiweek <- MMWRweek(ES27_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES64_ARIMA_WEEK2$epiweek <- MMWRweek(ES64_ARIMA_WEEK2$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK2$epiweek <- MMWRweek(ES64_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK2$epiweek <- MMWRweek(ES64_AVERAGE_WEEK2$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Week Ahead
df_W2 <- data.frame(
  STATE = AUTO_ARIMA_WEEK2$State,
  Julian_date = AUTO_ARIMA_WEEK2$target_end_date,
  epiweek = AUTO_ARIMA_WEEK2$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK2$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK2$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK2$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK2$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK2$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK2$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK2$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK2$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK2$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK2$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK2$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK2$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK2$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK2$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK2$WIS  
)

head(df_W2)
```

-------------
3 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK3$epiweek <- MMWRweek(AUTO_ARIMA_WEEK3$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK3$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK3$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK3$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK3$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK3$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK3$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES27_ARIMA_WEEK3$epiweek <- MMWRweek(ES27_ARIMA_WEEK3$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK3$epiweek <- MMWRweek(ES27_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK3$epiweek <- MMWRweek(ES27_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES64_ARIMA_WEEK3$epiweek <- MMWRweek(ES64_ARIMA_WEEK3$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK3$epiweek <- MMWRweek(ES64_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK3$epiweek <- MMWRweek(ES64_AVERAGE_WEEK3$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Week Ahead
df_W3 <- data.frame(
  STATE = AUTO_ARIMA_WEEK3$State,
  Julian_date = AUTO_ARIMA_WEEK3$target_end_date,
  epiweek = AUTO_ARIMA_WEEK3$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK3$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK3$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK3$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK3$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK3$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK3$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK3$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK3$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK3$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK3$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK3$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK3$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK3$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK3$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK3$WIS  
)

head(df_W3)

```

-------------
4 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK4$epiweek <- MMWRweek(AUTO_ARIMA_WEEK4$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK4$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK4$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK4$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK4$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK4$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK4$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES27_ARIMA_WEEK4$epiweek <- MMWRweek(ES27_ARIMA_WEEK4$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK4$epiweek <- MMWRweek(ES27_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK4$epiweek <- MMWRweek(ES27_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES64_ARIMA_WEEK4$epiweek <- MMWRweek(ES64_ARIMA_WEEK4$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK4$epiweek <- MMWRweek(ES64_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK4$epiweek <- MMWRweek(ES64_AVERAGE_WEEK4$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Week Ahead
df_W4 <- data.frame(
  STATE = AUTO_ARIMA_WEEK4$State,
  Julian_date = AUTO_ARIMA_WEEK4$target_end_date,
  epiweek = AUTO_ARIMA_WEEK4$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK4$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK4$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK4$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK4$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK4$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK4$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK4$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK4$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK4$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK4$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK4$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK4$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK4$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK4$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK4$WIS  
)

head(df_W4)
```


Filter only the flu season

```{r}
# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W1 <- df_W1 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W1)


# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W2 <- df_W2 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W2)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W3 <- df_W3 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W3)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W4 <- df_W4 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W4)
```

Calculate mean weighted interval score for all forecast weeks on each model.

```{r}

# Define the function
calculate_mean_wis <- function(data) {
  data %>%
    group_by(STATE) %>%
    summarize(
      AUTO_AR_LB = mean(AUTO_AR_LB, na.rm = TRUE),
      AUTO_ADJ_LB = mean(AUTO_ADJ_LB, na.rm = TRUE),
      AUTO_EPI_LB = mean(AUTO_EPI_LB, na.rm = TRUE),
      AUTO_TMP_LB = mean(AUTO_TEMP_LB, na.rm = TRUE),
      AUTO_AVG_LB = mean(AUTO_AVG_LB, na.rm = TRUE),
      
      ES27_AR_LB = mean(ES27_AR_LB, na.rm = TRUE),
      ES27_ADJ_LB = mean(ES27_ADJ_LB, na.rm = TRUE),
      ES27_EPI_LB = mean(ES27_EPI_LB, na.rm = TRUE),
      ES27_TMP_LB = mean(ES27_TEMP_LB, na.rm = TRUE),
      ES27_AVG_LB = mean(ES27_AVG_LB, na.rm = TRUE),
      
      ES64_AR_LB = mean(ES64_AR_LB, na.rm = TRUE),
      ES64_ADJ_LB = mean(ES64_ADJ_LB, na.rm = TRUE),
      ES64_EPI_LB = mean(ES64_EPI_LB, na.rm = TRUE),
      ES64_TMP_LB = mean(ES64_TEMP_LB, na.rm = TRUE),
      ES64_AVG_LB = mean(ES64_AVG_LB, na.rm = TRUE),
      
    )
}

# Now you can use the function with any dataframe
W1_Lg <- calculate_mean_wis(filtered_df_W1)
W2_Lg <- calculate_mean_wis(filtered_df_W2)
W3_Lg <- calculate_mean_wis(filtered_df_W3)
W4_Lg <- calculate_mean_wis(filtered_df_W4)

# Display the resulting dataframe
head(W1_Lg)
head(W2_Lg)
head(W3_Lg)
head(W4_Lg)
```

Here we have boxplots of the mean(WIS) by each state. 

```{r}
# Combine the data into one data frame
combined_data <- data.frame(
  week = rep(c("W1", "W2", "W3", "W4"), each = 48 * 15),
  
  Models = rep(c("AUTO_AR_LB", "ES27_AR_LB", "ES64_AR_LB", "AUTO_ADJ_LB", "ES27_ADJ_LB", "ES64_ADJ_LB", "AUTO_TMP_LB", "ES27_TMP_LB", "ES64_TMP_LB", "AUTO_EPI_LB", "ES27_EPI_LB", "ES64_EPI_LB", "AUTO_AVG_LB", "ES27_AVG_LB", "ES64_AVG_LB"), each=48, times = 4),
  
  value = c(W1_Lg$AUTO_AR_LB, W1_Lg$ES27_AR_LB, W1_Lg$ES64_AR_LB, 
            W1_Lg$AUTO_ADJ_LB, W1_Lg$ES27_ADJ_LB, W1_Lg$ES64_ADJ_LB, 
            W1_Lg$AUTO_TMP_LB, W1_Lg$ES27_TMP_LB, W1_Lg$ES64_TMP_LB, 
            W1_Lg$AUTO_EPI_LB, W1_Lg$ES27_EPI_LB, W1_Lg$ES64_EPI_LB,
            W1_Lg$AUTO_AVG_LB, W1_Lg$ES27_AVG_LB, W1_Lg$ES64_AVG_LB,
            
            W2_Lg$AUTO_AR_LB, W2_Lg$ES27_AR_LB, W2_Lg$ES64_AR_LB, 
            W2_Lg$AUTO_ADJ_LB, W2_Lg$ES27_ADJ_LB, W2_Lg$ES64_ADJ_LB, 
            W2_Lg$AUTO_TMP_LB, W2_Lg$ES27_TMP_LB, W2_Lg$ES64_TMP_LB, 
            W2_Lg$AUTO_EPI_LB, W2_Lg$ES27_EPI_LB, W2_Lg$ES64_EPI_LB,
            W2_Lg$AUTO_AVG_LB, W2_Lg$ES27_AVG_LB, W2_Lg$ES64_AVG_LB,            
            
            W3_Lg$AUTO_AR_LB, W3_Lg$ES27_AR_LB, W3_Lg$ES64_AR_LB, 
            W3_Lg$AUTO_ADJ_LB, W3_Lg$ES27_ADJ_LB, W3_Lg$ES64_ADJ_LB, 
            W3_Lg$AUTO_TMP_LB, W3_Lg$ES27_TMP_LB, W3_Lg$ES64_TMP_LB, 
            W3_Lg$AUTO_EPI_LB, W3_Lg$ES27_EPI_LB, W3_Lg$ES64_EPI_LB,
            W3_Lg$AUTO_AVG_LB, W3_Lg$ES27_AVG_LB, W3_Lg$ES64_AVG_LB,
            
            
            W4_Lg$AUTO_AR_LB, W4_Lg$ES27_AR_LB, W4_Lg$ES64_AR_LB, 
            W4_Lg$AUTO_ADJ_LB, W4_Lg$ES27_ADJ_LB, W4_Lg$ES64_ADJ_LB, 
            W4_Lg$AUTO_TMP_LB, W4_Lg$ES27_TMP_LB, W4_Lg$ES64_TMP_LB, 
            W4_Lg$AUTO_EPI_LB, W4_Lg$ES27_EPI_LB, W4_Lg$ES64_EPI_LB,
            W4_Lg$AUTO_AVG_LB, W4_Lg$ES27_AVG_LB, W4_Lg$ES64_AVG_LB)

)

# Create a new column for categories
combined_data <- combined_data %>%
  mutate(category = case_when(
    grepl("AR", Models) ~ "AR",
    grepl("EPI", Models) ~ "EPI",
    grepl("TMP", Models) ~ "TMP",
    grepl("ADJ", Models) ~ "ADJ",
    grepl("AVG", Models) ~ "AVG",
  ))

# Define color ramps for each category
colors_ar <- c("#a6cee3","#226e83", "#08306b")
colors_adj <- c("#fb9a99","red3", "#a11c3e")
colors_epi <- c("#cab2d6", "purple2", "#5e2b7b")
colors_tmp <- c("lightgreen","green3","#319045")
colors_avg <- c("orange","orange2", "orange3")

# Create a custom color mapping for each variable
custom_colors <- c(
  "AUTO_AR_LB" = colors_ar[1], "ES27_AR_LB" = colors_ar[2], "ES64_AR_LB" = colors_ar[3],
  "AUTO_EPI_LB" = colors_epi[1], "ES27_EPI_LB" = colors_epi[2], "ES64_EPI_LB" = colors_epi[3],
  "AUTO_TMP_LB" = colors_tmp[1], "ES27_TMP_LB" = colors_tmp[2], "ES64_TMP_LB" = colors_tmp[3],
  "AUTO_ADJ_LB" = colors_adj[1], "ES27_ADJ_LB" = colors_adj[2], "ES64_ADJ_LB" = colors_adj[3],
  "AUTO_AVG_LB" = colors_avg[1], "ES27_AVG_LB" = colors_avg[2], "ES64_AVG_LB" = colors_avg[3]
)

  # Create the box plot with additional facet for categories
plt2<-  ggplot(combined_data, aes(x = week, y = value, fill = Models)) +
    geom_boxplot(color = "black") +
    scale_fill_manual(values = custom_colors) +
    facet_wrap(category ~ Models , nrow = 5) +
    labs(
      title = "B) Models with log-back transformations",
      x = "",
      y = "Weighted Interval Score (WIS)"
    ) +
  scale_y_continuous(limits = c(0, 650)) +  # Set y-axis range
    theme_minimal()+
  theme(legend.position = "none")
plt2
#ggsave(plt2, height = 8, width = 10, filename="Fig1B.jpg")  
```



```{r}

# Combine in a 2x2 grid
combined_plot <- (plt1 | plt2) + 
  plot_annotation(
    title = "Mean WIS for the 24 models",
    subtitle = "Results by target week",
    theme = theme(plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))
  )
# Print
print(combined_plot) 

# Save to file
ggsave("Fig3.jpg", combined_plot, width =9, height =10)
```


COMBINING THE RESULTS WITH LOG AND NO LOG TRASNFORMATION

```{r}
W1<-merge(W1_Lg,W1_NoLg, by = "STATE")
W2<-merge(W2_Lg,W2_NoLg, by = "STATE")
W3<-merge(W3_Lg,W3_NoLg, by = "STATE")
W4<-merge(W4_Lg,W4_NoLg, by = "STATE")
```

Here I include a column with the best model result based on the lowest mean(WIS) of each state.

```{r}
# BEST RESULT

# Extract the columns of interest 
cols <- colnames(W1)[-1]
# Initialize a vector to store results
W1$Best_Result <- character(nrow(W1))

# Give me the model with lower WIS value in the best result column
for (i in 1:nrow(W1)) {
  # Find the column name with the minimum value for each row
  W1$Best_Result[i] <- cols[which.min(W1[i, cols])]
}

# REORDER BY FREQUENCY
W1$Best_Result <- fct_infreq(W1$Best_Result)
# Create a new column to classify the model type
W1$Model_Type <- ifelse(grepl("_LB$", W1$Best_Result), "With log-back transformation", "Without log-back transformation")

# Print the first rows
head(W1)

################################################

# Extract the columns of interest 
cols <- colnames(W2)[-1]
# Initialize a vector to store results
W2$Best_Result <- character(nrow(W2))
# Give me the model with lower WIS value in the best result column
for (i in 1:nrow(W2)) {
  # Find the column name with the minimum value for each row
  W2$Best_Result[i] <- cols[which.min(W2[i, cols])]
}

# REORDER BY FREQUENCY
W2$Best_Result <- fct_infreq(W2$Best_Result)
# Create a new column to classify the model type
W2$Model_Type <- ifelse(grepl("_LB$", W2$Best_Result),  "With log-back transformation","Without log-back transformation")

# Print merged results
head(W2)

######################################
# BEST RESULT
# Extract the columns of interest 
cols <- colnames(W3)[-1]
# Initialize a vector to store results
W3$Best_Result <- character(nrow(W3))

# Give me the model with lower WIS value in the best result column
for (i in 1:nrow(W3)) {
  # Find the column name with the minimum value for each row
  W3$Best_Result[i] <- cols[which.min(W3[i, cols])]
}

# REORDER BY FREQUENCY
W3$Best_Result <- fct_infreq(W3$Best_Result)
# Create a new column to classify the model type
W3$Model_Type <- ifelse(grepl("_LB$", W3$Best_Result),  "With log-back transformation","Without log-back transformation")

# Print merged results
head(W3)

###################################
# BEST RESULT
# Extract the columns of interest
cols <- colnames(W4)[-1]
# Initialize a vector to store results
W4$Best_Result <- character(nrow(W4))
# Give me the model with lower WIS value in the best result column
for (i in 1:nrow(W4)) {
  # Find the column name with the minimum value for each row
  W4$Best_Result[i] <- cols[which.min(W4[i, cols])]
}
W4$Best_Result <- fct_infreq(W4$Best_Result)
# Create a new column to classify the model type
W4$Model_Type <- ifelse(grepl("_LB$", W4$Best_Result),  "With log-back transformation","Without log-back transformation")
# Print merged results
head(W4)

```

Now, let's plot the best models by each state for each forecast horizon (1-4 weeks ahead). 

```{r}

# Create a custom color mapping for each variable
custom_colors <- c(
  "AUTO_AR_LB" = colors_ar[1], "ES27_AR_LB" = colors_ar[2], "ES64_AR_LB" = colors_ar[3],
  "AUTO_EPI_LB" = colors_epi[1], "ES27_EPI_LB" = colors_epi[2], "ES64_EPI_LB" = colors_epi[3],
  "AUTO_TMP_LB" = colors_tmp[1], "ES27_TMP_LB" = colors_tmp[2], "ES64_TMP_LB" = colors_tmp[3],
  "AUTO_ADJ_LB" = colors_adj[1], "ES27_ADJ_LB" = colors_adj[2], "ES64_ADJ_LB" = colors_adj[3],
  "AUTO_AVG_LB" = colors_avg[1], "ES27_AVG_LB" = colors_avg[2], "ES64_AVG_LB" = colors_avg[3],
  
  
  "AUTO_AR" = colors_ar[1], "ES27_AR" = colors_ar[2], "ES64_AR" = colors_ar[3],
  "AUTO_EPI" = colors_epi[1], "ES27_EPI" = colors_epi[2], "ES64_EPI" = colors_epi[3],
  "AUTO_TMP" = colors_tmp[1], "ES27_TMP" = colors_tmp[2], "ES64_TMP" = colors_tmp[3],
  "AUTO_ADJ" = colors_adj[1], "ES27_ADJ" = colors_adj[2], "ES64_ADJ" = colors_adj[3],
  "AUTO_AVG" = colors_avg[1], "ES27_AVG" = colors_avg[2], "ES64_AVG" = colors_avg[3]
)

# --------- WEEK1 MODELS ------------- #
plot1<- ggplot(W1, aes(x = Best_Result, fill = Best_Result)) +  
  geom_bar() +  
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Best model on the 48 U.S. states (W1)",       
       x = "", y = "Number of states") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  facet_wrap(~ Model_Type, scales = "free_x")

plot1

#ggsave("week1_best_models.jpg", plot1)

# --------- WEEK2 MODELS ------------- #
plot2<-ggplot(W2, aes(x = Best_Result, fill = Best_Result))  +  
  geom_bar() +  
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Best model on the 48 U.S. states (W2)",       
       x = "", y = "Number of states") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  facet_wrap(~ Model_Type, scales = "free_x")

#ggsave("week2_best_models.jpg", plot2)

plot2

# --------- WEEK3 MODELS ------------- #
plot3<-ggplot(W3, aes(x = Best_Result, fill = Best_Result))  +  
  geom_bar() +  
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Best model on the 48 U.S. states (W3)",       
       x = "", y = "Number of states") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  facet_wrap(~ Model_Type, scales = "free_x")
plot3

#ggsave("week3_best_models.jpg", plot3)

# --------- WEEK4 MODELS ------------- #
plot4<-ggplot(W4, aes(x = Best_Result, fill = Best_Result)) +  
  geom_bar() +  
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Best model on the 48 U.S. states (W4)",       
       x = "", y = "Number of states") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  facet_wrap(~ Model_Type, scales = "free_x")
plot4

#ggsave("week4_best_models.jpg", plot4)

```

Let's plot all results 

```{r}
library(ggplot2)
library(dplyr)

# Add a column to indicate the week ahead
W1$Week_Ahead <- "W1"
W2$Week_Ahead <- "W2"
W3$Week_Ahead <- "W3"
W4$Week_Ahead <- "W4"

# Combine all weeks into one dataframe
all_weeks <- bind_rows(W1, W2, W3, W4)

# Create the plot
combined_plot <- ggplot(all_weeks, aes(x = Best_Result, fill = Best_Result)) +
  geom_bar() +
  scale_fill_manual(values = custom_colors) +
  labs(title = "Best model based on the lowest mean WIS",
       subtitle = "Results for the 48 states on the contiguous U.S. by target week",
       x = "", y = "Number of states",
       fill = "Best model" ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 16, face = "bold")) +
  facet_grid(Week_Ahead ~ Model_Type, scales = "free_x")

# Save and display the plot
ggsave("Fig4.jpg", combined_plot, width =8, height =5)
print(combined_plot)

```
 
 Now we will utilize a Wilcox test with Holm p-value ajustment for repeated comparassion to evaluate the differences in model performances. 

1 WEEK AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
library(lme4)
library(ez)

# Reshape the data into long format
long_data <- W1 %>%
  pivot_longer(cols = c(-STATE,-Best_Result,-Model_Type,-Week_Ahead) , names_to = "Type", values_to = "Value")#%>%

wide_data <- long_data %>%
  pivot_wider(names_from = Type, values_from = Value)

# Get all model types except "AUTO_AAR"
model_types <- setdiff(names(wide_data), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against AUTO_AAR
wilcox_results <- map_df(model_types, function(model) {
  test <- wilcox.test(wide_data[[model]], wide_data$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# View results
p_values<-wilcox_results$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk1 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=1)
p_values_wk1 <-drop_na(p_values_wk1)
p_values_wk1

```

2 WEEKS AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Reshape the data into long format
long_data <- W2 %>%
  pivot_longer(cols = c(-STATE,-Best_Result,-Model_Type,-Week_Ahead) , names_to = "Type", values_to = "Value")#%>%
                          
################################
wide_data <- long_data %>%
  pivot_wider(names_from = Type, values_from = Value)

# Get all model types except "AUTO_AAR"
model_types <- setdiff(names(wide_data), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against AUTO_AAR
wilcox_results <- map_df(model_types, function(model) {
  test <- wilcox.test(wide_data[[model]], wide_data$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# View results
print(wilcox_results)

p_values<-wilcox_results$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk2 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=2)
p_values_wk2 <-drop_na(p_values_wk2)
p_values_wk2

```

3 WEEKS AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Reshape the data into long format
long_data <- W3 %>%
  pivot_longer(cols = c(-STATE,-Best_Result,-Model_Type,-Week_Ahead) , names_to = "Type", values_to = "Value")#%>%

######################
wide_data <- long_data %>%
  pivot_wider(names_from = Type, values_from = Value)

# Get all model types except "AUTO_AAR"
model_types <- setdiff(names(wide_data), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against AUTO_AAR
wilcox_results <- map_df(model_types, function(model) {
  test <- wilcox.test(wide_data[[model]], wide_data$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# View results
print(wilcox_results)

p_values<-wilcox_results$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk3 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=3)
p_values_wk3 <-drop_na(p_values_wk3)
p_values_wk3
```

4 WEEKS AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Reshape the data into long format
long_data <- W4 %>%
  pivot_longer(cols = c(-STATE,-Best_Result,-Model_Type,-Week_Ahead) , names_to = "Type", values_to = "Value")#%>%
#  mutate(Type = recode(Type, "AUTO_AR" = "AUTO_AR"))

######################
wide_data <- long_data %>%
  pivot_wider(names_from = Type, values_from = Value)

# Get all model types except "AUTO_AAR"
model_types <- setdiff(names(wide_data), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against AUTO_AAR
wilcox_results <- map_df(model_types, function(model) {
  test <- wilcox.test(wide_data[[model]], wide_data$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# Perform Wilcoxon test for each model type against AUTO_AAR
p_values<-wilcox_results$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk4 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=4)
p_values_wk4 <-drop_na(p_values_wk4)
p_values_wk4

```

Let's calculate the mean(WIS) improvement relative to the AUTO ARIMA model. We will compare each model with the AUTO ARIMA model for the same states. Later we sum the results of these comparisons. Positive results indicate that there was a general improvement in the mean(WIS) for a given model type among all states. Note that larger values on specific states may override a general trend and make the results less informative. So I do not strongly advice this analysis.

```{r}
calculate_percentage_of_improvement <- function(data) {
  return(data.frame(
    AUTO_AR = (data$AUTO_AR / data$AUTO_AR),
    
    ES27_AR = (((data$ES27_AR/data$AUTO_AR)-1) * 100),
    ES64_AR = (((data$ES64_AR/data$AUTO_AR )-1) * 100),
   
    AUTO_ADJ = (((data$AUTO_ADJ/data$AUTO_AR)-1) * 100),
    ES27_ADJ = (((data$ES27_ADJ/data$AUTO_AR)-1) * 100),
    ES64_ADJ = (((data$ES64_ADJ/data$AUTO_AR)-1) * 100),
    
    AUTO_TMP = (((data$AUTO_TMP/data$AUTO_AR)-1) * 100),
    ES27_TMP = (((data$ES27_TMP/data$AUTO_AR)-1) * 100),
    ES64_TMP = (((data$ES64_TMP/data$AUTO_AR)-1) * 100),
    
    AUTO_EPI = (((data$AUTO_EPI/data$AUTO_AR)-1) * 100),
    ES27_EPI = (((data$ES27_EPI/data$AUTO_AR)-1) * 100),
    ES64_EPI = (((data$ES64_EPI/data$AUTO_AR)-1) * 100),
    
    AUTO_AVG = (((data$AUTO_AVG/data$AUTO_AR)-1) * 100),
    ES27_AVG = (((data$ES27_AVG/data$AUTO_AR)-1) * 100),
    ES64_AVG = (((data$ES64_AVG/data$AUTO_AR)-1) * 100),
    
    AUTO_AR_LB = (((data$AUTO_AR_LB/data$AUTO_AR)-1) * 100),
    ES27_AR_LB = (((data$ES27_AR_LB/data$AUTO_AR)-1) * 100),
    ES64_AR_LB = (((data$ES64_AR_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_ADJ_LB = (((data$AUTO_ADJ_LB/data$AUTO_AR)-1) * 100),
    ES27_ADJ_LB = (((data$ES27_ADJ_LB/data$AUTO_AR)-1) * 100),
    ES64_ADJ_LB = (((data$ES64_ADJ_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_TMP_LB = (((data$AUTO_TMP_LB/data$AUTO_AR)-1) * 100),
    ES27_TMP_LB = (((data$ES27_TMP_LB/data$AUTO_AR)-1) * 100),
    ES64_TMP_LB = (((data$ES64_TMP_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_EPI_LB = (((data$AUTO_EPI_LB/data$AUTO_AR)-1) * 100),
    ES27_EPI_LB = (((data$ES27_EPI_LB/data$AUTO_AR)-1) * 100),
    ES64_EPI_LB = (((data$ES64_EPI_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_AVG_LB = (((data$AUTO_AVG_LB/data$AUTO_AR)-1) * 100),
    ES27_AVG_LB = (((data$ES27_AVG_LB/data$AUTO_AR)-1) * 100),
    ES64_AVG_LB = (((data$ES64_AVG_LB/data$AUTO_AR)-1) * 100)    
  ))
}

# Calculate percentage of improvemtn 
W1_percentage_of_improvement <- calculate_percentage_of_improvement(W1)
W2_percentage_of_improvement <- calculate_percentage_of_improvement(W2)
W3_percentage_of_improvement <- calculate_percentage_of_improvement(W3)
W4_percentage_of_improvement <- calculate_percentage_of_improvement(W4)

W4_percentage_of_improvement
```

Now let's plot a map of percentage of WIS improvement for each state.

Mean and sd percentage of improvement compared to auto_arima

```{r}
# List of column names
variables <-c(names(W1_percentage_of_improvement))

# Create an empty dataframe to store results
summary_impr <- data.frame(WeekAhead = character(), Model = character(), m = numeric(), sd = numeric(), stringsAsFactors = FALSE)

# List of datasets
datasets <- list("1" = W1_percentage_of_improvement, 
                 "2" = W2_percentage_of_improvement, 
                 "3" = W3_percentage_of_improvement, 
                 "4" = W4_percentage_of_improvement)

# Loop through datasets and variables
for (dataset_name in names(datasets)) {
  dataset <- datasets[[dataset_name]]  # Get the dataset
  
  for (var in variables) {
    data <- dataset[[var]]
    mean_val <- mean(data, na.rm = TRUE)
    sd_val <- sd(data, na.rm = TRUE)

    # Append results to dataframe
    summary_impr <- rbind(summary_impr, data.frame(WeekAhead = dataset_name, Model = var, m = mean_val, sd = sd_val))

    # Generate histogram
    p <- ggplot(dataset, aes(x = .data[[var]])) +
      geom_histogram(color = "black", fill = "lightblue", bins = 30, alpha = 0.7) +
      geom_vline(aes(xintercept = mean_val), color = "red", linetype = "dashed", linewidth = 1) +
      geom_vline(aes(xintercept = mean_val - sd_val), color = "blue", linetype = "dotted", linewidth = 1) +
      geom_vline(aes(xintercept = mean_val + sd_val), color = "blue", linetype = "dotted", linewidth = 1) +
      labs(title = paste("Histogram of", var, "in", dataset_name),
           x = var, 
           y = "Frequency") +
      theme_minimal()

    print(p)  # Display the plot
  }
}

summary_impr$WeekAhead<-as.numeric(summary_impr$WeekAhead)

summary_impr
```

Datasets with differences and Wilcoxon Holm adjusted p-values

```{r}
# 

all_p_values<-rbind(p_values_wk1,p_values_wk2,p_values_wk3,p_values_wk4)

p_values_and_impr <- merge(summary_impr, all_p_values, by = c("WeekAhead", "Model"))

# Create a new column "Model_Type" based on whether "NoLg" is in the Model name
p_values_and_impr$Model_Type <- ifelse(grepl("_LB$", p_values_and_impr$Model), "LB", "no_LB")

# View the updated dataframe
head(p_values_and_impr)
p_values_and_impr
```

Mean difference and standard deviation

```{r}

library(ggplot2)
library(dplyr)
library(forcats)

# Define significance threshold  
alpha <- 0.05   

# Get model order based on WeekAhead == 1  
model_order <- p_values_and_impr %>%
  filter(WeekAhead == 1) %>%
  arrange(desc(m)) %>%
  pull(Model)  # Extract ordered model names

# Prepare data with significance flag and ordering  
p_df <- p_values_and_impr %>%
  mutate(Significance = ifelse(p_values < alpha, "Significant", "Not Significant"),
         Model_Type = ifelse(grepl("_LB$", Model), "With log-back transformation", "Without log-back transformation"),
         Model = factor(Model, levels = model_order))  # Apply ordered factor

# Heatmap plot with models ordered by WeekAhead == 1  
plot_m_heatmap <- ggplot(p_df, aes(x = factor(WeekAhead), y = Model, fill = m)) +
  geom_tile(aes(fill = ifelse(Significance == "Significant", m, NA)), color = "black") +  # Fill only significant ones
  geom_tile(data = p_df %>% filter(Significance == "Not Significant"), 
            aes(x = factor(WeekAhead), y = Model), fill = "gray80", color = "black") +  # Gray for non-significant
  geom_text(aes(label = paste0("m:", round(m, 1),", sd:", round(sd, 1))), 
            color = "black", size = 4) +  # Add text labels
  scale_fill_gradient2(
  low = "cyan", 
  mid = "white", 
  high = "red", 
  midpoint = 0,     # <-- Sets 0 as the midpoint
  na.value = "gray80", 
  name = "Mean difference", 
  limits = c(-35, 35)       
)+
  
  labs(title = "Mean differences between models' WIS and the baseline across 48 states",
       subtitle = "Gray boxes indicate models that are not significantly different from the baseline (p>0.05)",
         caption = "m = mean difference, sd = standard deviation",
       x = "Target Ahead",
       y = "") + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
  plot.caption = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),) +
  facet_wrap(~ Model_Type, scales = "free_y")  # Separate NoLg and other models


# Print plot
print(plot_m_heatmap)
ggsave("Fig5.jpg", plot_m_heatmap, width = 14, height = 7 )

```

Now let's plot a map of percentage of WIS improvement for each state.

```{r}
# MAP 1 week ahead

W1_map <- data.frame(
  STATE = W1$STATE,
  percentage_improvement = W1_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG=W1$AUTO_AVG_LB
)

# Merge the best model data with the states map
W1_map <- states %>%
  left_join(W1_map, by = c("STATE")) %>%
  drop_na()

################################### MAP 2 weeka ahead

W2_map <- data.frame(
  STATE = W2$STATE,
  percentage_improvement = W2_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG=W2$AUTO_AVG_LB
)

# Merge the best model data with the states map
W2_map <- states %>%
  left_join(W2_map, by = c("STATE"))%>%
  drop_na()

##################################### MAP 3 weeka ahead

W3_map <- data.frame(
  STATE = W3$STATE,
  percentage_improvement = W3_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG=W3$AUTO_AVG_LB
)

# Merge the best model data with the states map
W3_map <- states %>%
  left_join(W3_map, by = c("STATE"))%>%
  drop_na() 

############################### MAP 4 weeka ahead

W4_map <- data.frame(
  STATE = W4$STATE,
  percentage_improvement = W4_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG=W4$AUTO_AVG_LB
)

# Merge the best model data with the states map
W4_map <- states %>%
  left_join(W4_map, by = c("STATE"))%>%
  drop_na()
```

Let's plot some maps with the best models in each state and the percentage of improvement compared to the AUTO ARIMA models for the same state.
Here I define some colors categories that I will use on the next maps.

1 week ahead percentage of improvement

```{r}

ES_1WEEK <- ggplot(W1_map) +
  geom_sf(aes(fill = AUTO_AVG)) +  # Fill based on the best model
  scale_fill_gradient2(low = "skyblue", mid = "lightyellow2", high = "red", midpoint = 100, limits = c(0, 352)) +  
  ggtitle("1 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W1_map, aes(label = round(AUTO_AVG,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "mean WIS",  
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range


ES_1WEEK<- ES_1WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_1WEEK
#ggsave(ES_1WEEK, height = 4.5, width = 6.5,  filename="Fig4A.jpg")  
```

2 weeks ahead

```{r}

ES_2WEEK <- ggplot(W2_map) +
  geom_sf(aes(fill = AUTO_AVG)) +  # Fill based on the best model
  scale_fill_gradient2(low = "skyblue", mid = "lightyellow2", high = "red", midpoint = 100, limits = c(0, 352)) +  
  ggtitle("2 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W2_map, aes(label = round(AUTO_AVG,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "mean WIS",
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_2WEEK <-ES_2WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_2WEEK
#ggsave(ES_2WEEK, height = 4.5, width = 6.5,  filename="Fig4B.jpg")  
```

3 weeks ahead

```{r}

ES_3WEEK <- ggplot(W3_map) +
  geom_sf(aes(fill = AUTO_AVG)) +  # Fill based on the best model
  scale_fill_gradient2(low = "skyblue", mid = "lightyellow2", high = "red", midpoint = 100, limits = c(0, 352)) +  
  ggtitle("3 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W3_map, aes(label = round(AUTO_AVG,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "mean WIS",
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_3WEEK<- ES_3WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_3WEEK
#ggsave(ES_3WEEK, height = 4.5, width = 6.5,  filename="Fig4C.jpg")  
```
4 weeks ahead

```{r}

ES_4WEEK <- ggplot(W4_map) +
  geom_sf(aes(fill = AUTO_AVG)) +
  scale_fill_gradient2(low = "skyblue", mid = "lightyellow2", high = "red", 
                       midpoint = 100, limits = c(0, 352)) +  
  ggtitle("4 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W4_map, aes(label = round(AUTO_AVG,0)),  
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +
  labs(
    fill = "mean WIS", 
       x = "",
       y = ""
  )

x_limits <- c(-125, -67)  
y_limits <- c(25, 50)    

ES_4WEEK<-ES_4WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_4WEEK
#ggsave(ES_4WEEK,height = 4.5, width = 6.5,  filename="Fig4D.jpg")  
```

Combine in a 2x2 grid

```{r}
# Combine in a 2x2 grid
combined_plot <- (ES_1WEEK | ES_2WEEK) /
                 (ES_3WEEK | ES_4WEEK) + 
  plot_annotation(
    title = "Mean WIS for the 48 states in the contiguous U.S.",
    subtitle = "Results for the the 2022/2023 and 2023/2024 influenza seasons",
    theme = theme(plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))
  )
# Print
print(combined_plot) 

# Save to file
ggsave("Fig6.jpg", combined_plot, width =12, height =7)

```

Loading datasets for regression analysis

```{r}
pop_data <- read.csv("NHSH_hospitalizations_seed/regression_features/population_data.csv") # resident population and population density
sovi_data <- read.csv("NHSH_hospitalizations_seed/regression_features/sovi_2010.2014.csv") # SOVI index
bric_data<-read.csv("NHSH_hospitalizations_seed/regression_features/bric2015.csv") # BRIC index
humidity_data<-read.csv("NHSH_hospitalizations_seed/regression_features/humidity_climatology_1990_2020.csv") # ERA5 Specific Humidity
temperature_data<-read.csv("NHSH_hospitalizations_seed/regression_features/temperature_climatology_1990_2020.csv") # ERA5 Specific Temperature

```

REGRESSION MODELS

We will run the regression for evaluating if the best model log(WIS) which represent its performance is related to given independent variables.

```{r}

# List of data frames
WIS_dataframes <- list(W1 = W1_map, W2 = W2_map, W3 = W3_map, W4=W4_map)
regression_models<-data.frame()

```

Percentage of AUTO_ADJ mean WIS

AUTO_ADJ WIS x RESIDENT POPULATION 2020

```{r}

for(i in c(1,2,3,4)){

  # Combining data for the same states
  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fitting the regression model
  model <- lm((WIS_pop_data$AUTO_AVG) ~ (WIS_pop_data$Resident_population_2020))
  # View the model summary
  model_summary <- summary(model)
  # Getting the R and p values for the plot
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # Saving the results in a dataframe
  regression_models2 <- data.frame(
    independent_variable = "Resident Population (2020)", 
    Week_Ahead = i, 
    r_squared = r_squared, 
    p_value = p_value
  )
  # Append to the main results dataframe
  regression_models <- rbind(regression_models, regression_models2)
}

regression_models


```

best regression plot

```{r}
plot_list <- list()  # store plots

for(i in 1:4) {
  
  # Combine WIS data and population
  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  
  # Fit linear model
  model <- lm(AUTO_AVG ~ Resident_population_2020, data = WIS_pop_data)
  model_summary <- summary(model)
  
  # Save R² and p-values
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  
  # Create plot
  p <- ggplot(WIS_pop_data, aes(x = Resident_population_2020, y = AUTO_AVG)) +
    geom_point(color = "steelblue", size = 2) +
    geom_smooth(method = "lm", se = FALSE, color = "darkred", linetype = "dashed") +
    labs(
      title = paste("Regression","Target Week", i),
      subtitle = paste("R² =", r_squared, "| p =", p_value),
      x = "Resident Population (2020)",
      y = "AUTO_AVG"
    ) +
    theme_minimal()
  
  # Store the plot
  plot_list[[i]] <- p
}


# Combine the plots vertically
combined_regressions <- wrap_plots(plot_list, ncol = 1)

# Display (optional)
combined_regressions

# Save the combined plot
#ggsave("Figx.png", combined_plot, width = 3, height = 5, dpi = 600)
```

AUTO_ADJ WIS x POPULATION DENSITY

```{r}

for(i in c(1,2,3,4)){

  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_pop_data$AUTO_AVG) ~ (WIS_pop_data$Population_density_2020))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Population Density (2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # Append to the main results dataframe
  regression_models<-rbind(regression_models,regression_models2)
}

```

Here we will weight the Social Vulnerability Index (SoVI) and Baseline Resilience Indicators for Communities (BRIC) county indexes which for each states based on the population size in each county.

```{r}

#############################################################
# SOVI BY STATE
# weighted by population size in each county
sovi_by_state <- sovi_data %>%
  filter(!is.nan(sovi)) %>%  # Exclude rows where 'sovi' is NaN
  group_by(state.name) %>%
  summarize(weighted_mean = weighted.mean(sovi, w = population.2020, na.rm = TRUE))

colnames(sovi_by_state)[1] <- "STATE"

#############################################################
# BRIC BY STATE
# weighted by population size in each county

bric_by_state <- bric_data %>%
  group_by(state.name) %>%
  summarize(across(16:22, ~ weighted.mean(.x, w = population.2020, na.rm = TRUE), .names = "weighted_mean_{col}"))
colnames(bric_by_state)[1] <- "STATE"

```

AUTO_AVG WIS x SOVI

```{r}

for(i in c(1,2,3,4)){

  WIS_sovi<-NULL
  WIS_sovi <- inner_join(WIS_dataframes[[i]], sovi_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_sovi$AUTO_AVG) ~ (WIS_sovi$weighted_mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Social Vulnerability Index (SoVI)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC SOCIAL

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model  
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.social))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Social (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC ECONOMIC

```{r}
for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.economic))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Economic (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC Infrastructure

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.infrastructure))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Infrastructure (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC institutional

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.institutional))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Institutional (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC community

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[1]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.community))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Community (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC environment

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.environment))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Environment (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC total

```{r}

for(i in 1:4){
  # BRIC INDEX
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.total))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC total (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}
```

TEMPERATUE - ERA5

Now we will look at regression models that uses mean temperature and specific humidity.

-------------------

AUTO_AVG WIS x Temperature ERA5 Data

```{r}
for(i in 1:4){
  # TEMPERATURE DATA from ERA5
  WIS_temp <- inner_join(WIS_dataframes[[i]], temperature_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_temp$AUTO_AVG) ~ (WIS_temp$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Temperature (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}
```

AUTO_AVG WIS x Specific Humidity ERA5 Data

```{r}
library(ggpubr)

# regression results 
print(regression_models)

for(i in 1:4){
  # HUMIDITY DATA from ERA5
  WIS_humidity <- inner_join(WIS_dataframes[[i]], humidity_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_humidity$AUTO_AVG) ~ (WIS_humidity$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Specific Humidty (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

# Plot the table
regression_models
```

SUMMARY OF RESULTS 

```{r}
# Define a significance threshold (p < 0.05)
regression_models <- regression_models %>%
  mutate(significance = ifelse(p_value < 0.05, "Significant", "Not Significant"))

# Plot
reg2<-ggplot(regression_models, aes(x = Week_Ahead, y = independent_variable, fill = significance)) +  
  geom_tile(color = "black") +  # Add black borders to squares
  geom_text(aes(label = round(r_squared, 3)), color = "black", size = 6) +  # Text inside boxes
  scale_fill_manual(values = c("Significant" = "cyan", "Not Significant" = "gray")) +  
  labs(title = "Regression models R²",
       subtitle = "Mean WIS as dependent variable",
       x = "Target Week",
       y = "Independent Variables",
       fill = "Significance (p < 0.05)") +  
  theme_minimal() +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))

reg2

# Combine the plots vertically
reg2_scatter <- reg2 | combined_regressions 
reg2_scatter
ggsave(reg2_scatter, height = 6, width = 12, filename="Fig7.jpg")  
#ggsave(reg2, filename="reg2.jpg",height = 8, width = 10)
```


Let's plot some maps with the with the mean (%) of difference between the AUTO_AVG and the AUTO ARIMA models for the same state.

1 week ahead percentage of improvement

```{r}

ES_1WEEK <- ggplot(W1_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("1 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W1_map, aes(label = round(percentage_improvement,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_1WEEK<-ES_1WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

#ggsave(ES_1WEEK,height = 4.5, width = 6.5,  filename="Fig5A.jpg")  
```
2 weeks ahead

```{r}

ES_2WEEK <- ggplot(W2_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("2 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W2_map, aes(label = round(percentage_improvement,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle


x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_2WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

#ggsave(ES_2WEEK, height = 4.5, width = 6.5, filename="Fig5B.jpg")  
```

3 weeks ahead

```{r}

ES_3WEEK <- ggplot(W3_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("3 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W3_map, aes(label = round(percentage_improvement,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill =  "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_3WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

#ggsave(ES_3WEEK, height = 4.5, width = 6.5, filename="Fig5C.jpg")  
```
4 weeks ahead

```{r}
ES_4WEEK <- ggplot(W4_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("4 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W4_map, aes(label = round(percentage_improvement,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_4WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

#ggsave(ES_4WEEK, height = 4.5, width = 6.5,  filename="Fig5D.jpg")  
```

```{r}
# Ensure each plot has coord_sf applied
ES_1WEEK <- ES_1WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_2WEEK <- ES_2WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_3WEEK <- ES_3WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_4WEEK <- ES_4WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

# Combine in a 2x2 grid
combined_plot <- (ES_1WEEK | ES_2WEEK) /
                 (ES_3WEEK | ES_4WEEK) + 
  plot_annotation(
    title = "Mean WIS differences compared to the baseline",
    subtitle = "Results by forecast horizon",
    theme = theme(plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))
  )
# Print
print(combined_plot) 

# Save to file
ggsave("Fig8.jpg", combined_plot, width =12, height =7)
```

REGRESSION MODELS

We will run the regression for evaluating if the best model log(WIS) which represent its performance is related to given independent variables.

```{r}

# List of data frames
WIS_dataframes <- list(W1 = W1_map, W2 = W2_map, W3 = W3_map, W4=W4_map)
regression_models<-data.frame()

```

Percentage of improvement regression analysis

AUTO_AVG WIS x RESIDENT POPULATION 2020

```{r}

for(i in c(1,2,3,4)){

  # Combining data for the same states
  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fitting the regression model
  model <- lm((WIS_pop_data$percentage_improvement) ~ (WIS_pop_data$Resident_population_2020))
  # View the model summary
  model_summary <- summary(model)
  # Getting the R and p values for the plot
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # Saving the results in a dataframe
  regression_models2 <- data.frame(
    independent_variable = "Resident Population (2020)", 
    Week_Ahead = i, 
    r_squared = r_squared, 
    p_value = p_value
  )
  # Append to the main results dataframe
  regression_models <- rbind(regression_models, regression_models2)
}

regression_models
```

AUTO_AVG WIS x POPULATION DENSITY

```{r}

for(i in c(1,2,3,4)){

  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_pop_data$percentage_improvement) ~ (WIS_pop_data$Population_density_2020))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Population Density (2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # Append to the main results dataframe
  regression_models<-rbind(regression_models,regression_models2)
}

```

Here we will weight the Social Vulnerability Index (SoVI) and Baseline Resilience Indicators for Communities (BRIC) county indexes which for each states based on the population size in each county.

```{r}
#############################################################
# SOVI BY STATE
# weighted by population size in each county
sovi_by_state <- sovi_data %>%
  filter(!is.nan(sovi)) %>%  # Exclude rows where 'sovi' is NaN
  group_by(state.name) %>%
  summarize(weighted_mean = weighted.mean(sovi, w = population.2020, na.rm = TRUE))

colnames(sovi_by_state)[1] <- "STATE"

#############################################################
# BRIC BY STATE
# weighted by population size in each county

bric_by_state <- bric_data %>%
  group_by(state.name) %>%
  summarize(across(16:22, ~ weighted.mean(.x, w = population.2020, na.rm = TRUE), .names = "weighted_mean_{col}"))
colnames(bric_by_state)[1] <- "STATE"

```

AUTO_AVG WIS x SOVI

```{r}

for(i in c(1,2,3,4)){

  WIS_sovi<-NULL
  WIS_sovi <- inner_join(WIS_dataframes[[i]], sovi_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_sovi$percentage_improvement) ~ (WIS_sovi$weighted_mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Social Vulnerability Index (SoVI)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC SOCIAL

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model  
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.social))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Social (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC ECONOMIC

```{r}
for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.economic))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Economic (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC Infrastructure

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.infrastructure))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Infrastructure (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```


best regression plot

```{r}

# Prepare a list to hold your plots
bric_plots <- list()

for (i in 1:4) {
  # 1) Join the WIS and BRIC data
  WIS_bric <- inner_join(
    WIS_dataframes[[i]],
    bric_by_state,
    by = "STATE"
  )
  
  # 2) Fit the linear model
  model <- lm(
    percentage_improvement ~ weighted_mean_z_bric.infrastructure,
    data = WIS_bric
  )
  ms <- summary(model)
  
  # 3) Extract R² and p‐value
  r2 <- round(ms$r.squared, 3)
  p  <- signif(ms$coefficients[2, 4], 3)
  
  # 4) Build the ggplot
  p <- ggplot(WIS_bric,
              aes(x = weighted_mean_z_bric.infrastructure,
                  y = percentage_improvement)) +
    geom_point(color = "steelblue", size = 2) +
    geom_smooth(method = "lm", se = FALSE, color = "darkred") +
    labs(
      title    = paste("Regression","Target Week", i),
      subtitle = paste0("R² = ", r2, "   p = ", p),
      x        = "BRIC infrastructure (2015)",
      y        = "Difference"
    ) +
    theme_minimal()
  
  # 5) Store it
  bric_plots[[i]] <- p
}

# Combine the plots vertically
combined_regressions <- wrap_plots(bric_plots, ncol = 1)

# Display 
combined_regressions

```

AUTO_AVG WIS x BRIC institutional

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.institutional))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Institutional (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC community

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[1]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.community))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Community (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC environment

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.environment))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Environment (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC total

```{r}

for(i in 1:4){
  # BRIC INDEX
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.total))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC total (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}
```

TEMPERATUE - ERA5

Now we will look at regression models that uses mean temperature and specific humidity.

-------------------

AUTO_AVG WIS x Temperature ERA5 Data

```{r}


for(i in 1:4){
  # TEMPERATURE DATA from ERA5
  WIS_temp <- inner_join(WIS_dataframes[[i]], temperature_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_temp$percentage_improvement) ~ (WIS_temp$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Temperature (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}
```

AUTO_AVG WIS x Specific Humidity ERA5 Data

```{r}

# regression results 
print(regression_models)

for(i in 1:4){
  # HUMIDITY DATA from ERA5
  WIS_humidity <- inner_join(WIS_dataframes[[i]], humidity_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_humidity$percentage_improvement) ~ (WIS_humidity$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Specific Humidty (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

# Plot the table
regression_models
```

SUMMARY OF RESULTS 

```{r}
# Define a significance threshold (p < 0.05)
regression_models <- regression_models %>%
  mutate(significance = ifelse(p_value < 0.05, "Significant", "Not Significant"))

# Plot
reg2<-ggplot(regression_models, aes(x = Week_Ahead, y = independent_variable, fill = significance)) +  
  geom_tile(color = "black") +  # Add black borders to squares
  geom_text(aes(label = round(r_squared, 3)), color = "black", size = 6) +  # Text inside boxes
  scale_fill_manual(values = c("Significant" = "cyan", "Not Significant" = "gray")) +  
  labs(title = "Regression models R²",
       subtitle = "Mean WIS differences (%) as dependent variable",
       x = "Target Week",
       y = "Independent Variables",
       fill = "Significance (p < 0.05)") +    
  theme_minimal() +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))

reg2

reg2_scatter <- reg2 | combined_regressions 
reg2_scatter
ggsave(reg2_scatter, height = 6, width = 12, filename="Fig9.jpg")  
#ggsave(reg2, filename="Fig9.jpg",height = 6, width = 8)
```

```{r}
# Create a list of data frames for the four weeks
weeks <- 1:4
summed_data_list <- list()

for (week in weeks) {
  # Merge the data frames for the current week
  data__ <- merge(get(paste0("filtered_df_W", week, "_NoLg")),
                  get(paste0("filtered_df_W", week)))
  
  # Sum values by Julian date across all states
  summed_data <- data__ %>%
    group_by(Julian_date) %>%
    summarize(
      AUTO_AR = mean(AUTO_AR, na.rm = TRUE),  # Sum across all states
      AUTO_AVG_LB = mean(AUTO_AVG_LB, na.rm = TRUE)           # Sum across all states
    ) %>%
    # Calculate the difference ratio
    mutate(Difference =  ((AUTO_AVG_LB / AUTO_AR)-1)*100,
           Week = paste0("Week ", week))
  
  # Store the summarized data in the list
  summed_data_list[[week]] <- summed_data
}

# Combine all weeks into a single data frame
summed_data_all <- bind_rows(summed_data_list)

# Plot the difference using ggplot2
model_improv<-ggplot(summed_data_all, aes(x = Julian_date, y = (Difference), color = Week)) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 0, color = "black", linetype = "dashed", size = 0.8) +
  theme_minimal() +
  labs(
    title = "Weekly mean WIS differences across all states",
    subtitle = "AUTO_AVG_LB compared to baseline",
    x = "",
    y = "Mean difference"
  ) +
  scale_y_continuous(
    limits = c(-100, 100),
    breaks = seq(-100, 100, by = 20)
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %y"
  ) +
  scale_color_manual(
    values = c(
    "Week 1" = "#00BFC4",  # Bright cyan
    "Week 2" = "#F8766D",  # Bright coral red
    "Week 3" = "#7CAE00",  # Lime green
    "Week 4" = "#C77CFF"   # Bright purple
  )
  ) +
  theme(
    plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

model_improv

#ggsave(model_improv, height = 4.5, width = 9,  filename="Fig10.jpg")  
```
hospitalizations

```{r}

total_hospitalizations_by_week <- AUTO_ADJACENT_WEEK1 %>%
  filter(epiweek >= 40 | epiweek <= 20) %>%  # Apply filter AFTER epiweek exists
  group_by(target_end_date) %>%
  summarise(mean_cases = sum(cases, na.rm = TRUE))

hospital_plot <-ggplot(total_hospitalizations_by_week, aes(x = target_end_date, y = mean_cases)) +
  geom_bar(stat = "identity",fill = "steelblue") +
  labs(title = "Total influenza hospitalizations on the 48 states",
       x = "",
       y = "Influenza hospitalizations") +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %y"
  ) +
  theme_minimal()+
  theme(plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),
    axis.text.x = element_text(angle = 45, hjust = 1))

hospital_plot

```


```{r}

# Combine the plots vertically
combined_plot <- hospital_plot / model_improv

# Display (optional)
combined_plot

# Save the combined plot
ggsave("Fig10.jpg", combined_plot, width = 7, height = 7, dpi = 600)

```