---
title: "Manuscript results: Forecasting influenza using ARIMA and ARIMAX"
author: "Victor Felix"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  pdf_document: default
---

This document has the results that we present in our manuscript draft. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading libraries.

```{r}
library("tidyr")
library("MMWRweek")
library("data.table")
library("caret")
library("purrr")
library("dplyr")
library("tseries")
library("gtools")
library("forecast")
library("scoringutils")
library("covidHubUtils")
library("parallel")
library("future")#https://cran.r-project.org/web/packages/future/vignettes/future-4-issues.html
library("listenv")
library("epitools")
library("ggplot2")
library("sf")
library("forcats")
library("ggplot2")
library("sf")
library("dplyr")
library("scales") 
library("ggplot2")
library("broom")
library("fields")
library("ggpubr")
library("patchwork")
library("ggpattern")
library("cowplot")
library("lme4")
library("ez")
```

Loading the results of each model and the shapefiles of the maps.

```{r}

load("NHSH_hospitalizations_seed_nolog_correct/ES_ARIMA/ARIMA_MODELS_influenza_hospitalization_nolog.Rdata")
load("NHSH_hospitalizations_seed_nolog_correct/ES_ADJACENT/ADJACENT_MODELS_influenza_hospitalization_nolog.Rdata")
load("NHSH_hospitalizations_seed_nolog_correct/ES_EPIWEEK/EPIWEEK_MODELS_influenza_hospitalization_nolog.Rdata")
load("NHSH_hospitalizations_seed_nolog_correct/ES_TEMPERATURE/TEMPERATURE_MODELS_influenza_hospitalization_nolog.Rdata")
load("NHSH_hospitalizations_seed_nolog_correct/ES_AVERAGE/AVERAGE_MODELS_influenza_hospitalization_nolog.Rdata")

states <- read_sf("NHSH_hospitalizations_seed_nolog_correct/shapefiles/cb_2018_us_state_500k.shp")

states <- states %>%
  rename(STATE = NAME)

```

------------
1 Week ahead
------------
```{r}

# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK1$epiweek <- MMWRweek(AUTO_ARIMA_WEEK1$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK1$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK1$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK1$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK1$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK1$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK1$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES27_ARIMA_WEEK1$epiweek <- MMWRweek(ES27_ARIMA_WEEK1$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK1$epiweek <- MMWRweek(ES27_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK1$epiweek <- MMWRweek(ES27_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES64_ARIMA_WEEK1$epiweek <- MMWRweek(ES64_ARIMA_WEEK1$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK1$epiweek <- MMWRweek(ES64_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK1$epiweek <- MMWRweek(ES64_AVERAGE_WEEK1$target_end_date)$MMWRweek

# Dataframe that will be analysed for 1 Week Ahead
df_W1_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK1$State,
  Julian_date = AUTO_ARIMA_WEEK1$target_end_date,
  epiweek = AUTO_ARIMA_WEEK1$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK1$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK1$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK1$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK1$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK1$WIS,
  
  ES27_AR=ES27_ARIMA_WEEK1$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK1$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK1$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK1$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK1$WIS,
  
  ES64_AR=ES64_ARIMA_WEEK1$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK1$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK1$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK1$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK1$WIS
)

head(df_W1_NoLg)
```

------------
2 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK2$epiweek <- MMWRweek(AUTO_ARIMA_WEEK2$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK2$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK2$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK2$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK2$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK2$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK2$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES27_ARIMA_WEEK2$epiweek <- MMWRweek(ES27_ARIMA_WEEK2$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK2$epiweek <- MMWRweek(ES27_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK2$epiweek <- MMWRweek(ES27_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES64_ARIMA_WEEK2$epiweek <- MMWRweek(ES64_ARIMA_WEEK2$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK2$epiweek <- MMWRweek(ES64_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK2$epiweek <- MMWRweek(ES64_AVERAGE_WEEK2$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Weeks Ahead
df_W2_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK2$State,
  Julian_date = AUTO_ARIMA_WEEK2$target_end_date,
  epiweek = AUTO_ARIMA_WEEK2$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK2$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK2$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK2$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK2$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK2$WIS,
  
  ES27_AR=ES27_ARIMA_WEEK2$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK2$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK2$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK2$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK2$WIS,
  
  ES64_AR=ES64_ARIMA_WEEK2$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK2$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK2$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK2$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK2$WIS
  
)

head(df_W2_NoLg)
```

-------------
3 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK3$epiweek <- MMWRweek(AUTO_ARIMA_WEEK3$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK3$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK3$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK3$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK3$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK3$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK3$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES27_ARIMA_WEEK3$epiweek <- MMWRweek(ES27_ARIMA_WEEK3$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK3$epiweek <- MMWRweek(ES27_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK3$epiweek <- MMWRweek(ES27_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES64_ARIMA_WEEK3$epiweek <- MMWRweek(ES64_ARIMA_WEEK3$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK3$epiweek <- MMWRweek(ES64_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK3$epiweek <- MMWRweek(ES64_AVERAGE_WEEK3$target_end_date)$MMWRweek


# Dataframe that will be analysed for 3 Weeks Ahead
df_W3_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK3$State,
  Julian_date = AUTO_ARIMA_WEEK3$target_end_date,
  epiweek = AUTO_ARIMA_WEEK3$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK3$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK3$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK3$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK3$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK3$WIS,
    
  ES27_AR=ES27_ARIMA_WEEK3$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK3$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK3$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK3$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK3$WIS,
    
  ES64_AR=ES64_ARIMA_WEEK3$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK3$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK3$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK3$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK3$WIS
)

head(df_W3_NoLg)
```

-------------
4 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK4$epiweek <- MMWRweek(AUTO_ARIMA_WEEK4$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK4$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK4$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK4$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK4$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK4$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK4$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES27_ARIMA_WEEK4$epiweek <- MMWRweek(ES27_ARIMA_WEEK4$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK4$epiweek <- MMWRweek(ES27_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK4$epiweek <- MMWRweek(ES27_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES64_ARIMA_WEEK4$epiweek <- MMWRweek(ES64_ARIMA_WEEK4$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK4$epiweek <- MMWRweek(ES64_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK4$epiweek <- MMWRweek(ES64_AVERAGE_WEEK4$target_end_date)$MMWRweek

# Dataframe that will be analysed for 4 Weeks Ahead
df_W4_NoLg <- data.frame(
  STATE = AUTO_ARIMA_WEEK4$State,
  Julian_date = AUTO_ARIMA_WEEK4$target_end_date,
  epiweek = AUTO_ARIMA_WEEK4$epiweek,
  AUTO_AR=AUTO_ARIMA_WEEK4$WIS, 
  AUTO_ADJ=AUTO_ADJACENT_WEEK4$WIS, 
  AUTO_EPI=AUTO_EPIWEEK_WEEK4$WIS,
  AUTO_TEMP=AUTO_TEMPERATURE_WEEK4$WIS,
  AUTO_AVG=AUTO_AVERAGE_WEEK4$WIS, 
  
  ES27_AR=ES27_ARIMA_WEEK4$WIS, 
  ES27_ADJ=ES27_ADJACENT_WEEK4$WIS, 
  ES27_EPI=ES27_EPIWEEK_WEEK4$WIS,
  ES27_TEMP=ES27_TEMPERATURE_WEEK4$WIS,
  ES27_AVG=ES27_AVERAGE_WEEK4$WIS,  
  
  ES64_AR=ES64_ARIMA_WEEK4$WIS, 
  ES64_ADJ=ES64_ADJACENT_WEEK4$WIS, 
  ES64_EPI=ES64_EPIWEEK_WEEK4$WIS,
  ES64_TEMP=ES64_TEMPERATURE_WEEK4$WIS,
  ES64_AVG=ES64_AVERAGE_WEEK4$WIS  
)

head(df_W4_NoLg)
```

Filter only the flu season

```{r}
# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W1_NoLg <- df_W1_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W1_NoLg)


# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W2_NoLg <- df_W2_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W2_NoLg)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W3_NoLg <- df_W3_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W3_NoLg)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W4_NoLg <- df_W4_NoLg %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W4_NoLg)
```

Weighted interval scores for each state and each target week.

```{r}

# Combine all datasets and add a column to identify them
df_combined_ <- bind_rows(
  df_W1_NoLg %>% mutate(Dataset = "1 week ahead"),
  df_W2_NoLg %>% mutate(Dataset = "2 weeks ahead"),
  df_W3_NoLg %>% mutate(Dataset = "3 weeks ahead"),
  df_W4_NoLg %>% mutate(Dataset = "4 weeks ahead")
) %>%
  select(STATE, epiweek, AUTO_AR, Dataset, Julian_date) %>%
  rename(WIS = AUTO_AR)  # Rename for consistency

# Define the epiweek values to highlight
highlight_weeks <- c(21, 41)

# Get corresponding Julian dates for these epiweeks
highlight_dates <- df_combined_ %>%
  filter(epiweek %in% highlight_weeks) %>%
  select(epiweek, Julian_date) %>%
  distinct()

# Plot
plt0 <- ggplot(df_combined_, aes(x = Julian_date, y = WIS, group = STATE)) + 
  geom_vline(data = highlight_dates, aes(xintercept = Julian_date), color = "red", linetype = "dashed", size = 1) +  
  geom_line(color = "black", size = 0.1) +  
  facet_wrap(~ Dataset, ncol = 2, scales = "free_y") +  
  theme_minimal() +  
  labs(title = "Baseline model WIS for 48 states on the contiguous U.S.",#,
       subtitle = "Weeks between the dashed red lines are outside of the influenza season",
       x = "", 
       y = "WIS") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 16, face = "bold"),
        legend.position = "none") +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %y"
  ) # Format x-axis to show months and set monthly breaks

# Print the plot
plt0

ggsave(plt0, height = 5, width = 8, filename="Fig2.jpg")  
```

Computing mean weighted interval score for all target week for each model.

```{r}

# Define the function
calculate_mean_wis <- function(data) {
  data %>%
    group_by(STATE) %>%
    summarize(
      AUTO_AR = mean(AUTO_AR, na.rm = TRUE),
      AUTO_ADJ = mean(AUTO_ADJ, na.rm = TRUE),
      AUTO_EPI = mean(AUTO_EPI, na.rm = TRUE),
      AUTO_TMP = mean(AUTO_TEMP, na.rm = TRUE),
      AUTO_AVG = mean(AUTO_AVG, na.rm = TRUE),
      
      ES27_AR = mean(ES27_AR, na.rm = TRUE),
      ES27_ADJ = mean(ES27_ADJ, na.rm = TRUE),
      ES27_EPI = mean(ES27_EPI, na.rm = TRUE),
      ES27_TMP = mean(ES27_TEMP, na.rm = TRUE),
      ES27_AVG = mean(ES27_AVG, na.rm = TRUE),
      
      ES64_AR = mean(ES64_AR, na.rm = TRUE),
      ES64_ADJ = mean(ES64_ADJ, na.rm = TRUE),
      ES64_EPI = mean(ES64_EPI, na.rm = TRUE),
      ES64_TMP = mean(ES64_TEMP, na.rm = TRUE),
      ES64_AVG = mean(ES64_AVG, na.rm = TRUE)
    )
}

# Now you can use the function with any dataframe
W1_NoLg <- calculate_mean_wis(filtered_df_W1_NoLg)
W2_NoLg <- calculate_mean_wis(filtered_df_W2_NoLg)
W3_NoLg <- calculate_mean_wis(filtered_df_W3_NoLg)
W4_NoLg <- calculate_mean_wis(filtered_df_W4_NoLg)

# Display the resulting dataframe
head(W1_NoLg)
head(W2_NoLg)
head(W3_NoLg)
head(W4_NoLg)

```

Boxplots of the mean(WIS) by each state. 

```{r}
# Combine the data into one data frame
combined_data <- data.frame(
  week = rep(c("W1", "W2", "W3", "W4"), each = 48 * 15),
  
  Models = rep(c("AUTO_AR", "ES27_AR", "ES64_AR", "AUTO_ADJ", "ES27_ADJ", "ES64_ADJ", "AUTO_TMP", "ES27_TMP", "ES64_TMP", "AUTO_EPI", "ES27_EPI", "ES64_EPI","AUTO_AVG", "ES27_AVG", "ES64_AVG"), each=48, times = 4),
  
  value = c(W1_NoLg$AUTO_AR, W1_NoLg$ES27_AR, W1_NoLg$ES64_AR, 
            W1_NoLg$AUTO_ADJ, W1_NoLg$ES27_ADJ, W1_NoLg$ES64_ADJ, 
            W1_NoLg$AUTO_TMP, W1_NoLg$ES27_TMP, W1_NoLg$ES64_TMP, 
            W1_NoLg$AUTO_EPI, W1_NoLg$ES27_EPI, W1_NoLg$ES64_EPI,
            W1_NoLg$AUTO_AVG, W1_NoLg$ES27_AVG, W1_NoLg$ES64_AVG,
              
            W2_NoLg$AUTO_AR, W2_NoLg$ES27_AR, W2_NoLg$ES64_AR, 
            W2_NoLg$AUTO_ADJ, W2_NoLg$ES27_ADJ, W2_NoLg$ES64_ADJ, 
            W2_NoLg$AUTO_TMP, W2_NoLg$ES27_TMP, W2_NoLg$ES64_TMP, 
            W2_NoLg$AUTO_EPI, W2_NoLg$ES27_EPI, W2_NoLg$ES64_EPI,
            W2_NoLg$AUTO_AVG, W2_NoLg$ES27_AVG, W2_NoLg$ES64_AVG,
            
            W3_NoLg$AUTO_AR, W3_NoLg$ES27_AR, W3_NoLg$ES64_AR,
            W3_NoLg$AUTO_ADJ, W3_NoLg$ES27_ADJ, W3_NoLg$ES64_ADJ, 
            W3_NoLg$AUTO_TMP, W3_NoLg$ES27_TMP, W3_NoLg$ES64_TMP, 
            W3_NoLg$AUTO_EPI, W3_NoLg$ES27_EPI, W3_NoLg$ES64_EPI,
            W3_NoLg$AUTO_AVG, W3_NoLg$ES27_AVG, W3_NoLg$ES64_AVG,
            
            W4_NoLg$AUTO_AR, W4_NoLg$ES27_AR, W4_NoLg$ES64_AR,
            W4_NoLg$AUTO_ADJ, W4_NoLg$ES27_ADJ, W4_NoLg$ES64_ADJ, 
            W4_NoLg$AUTO_TMP, W4_NoLg$ES27_TMP, W4_NoLg$ES64_TMP, 
            W4_NoLg$AUTO_EPI, W4_NoLg$ES27_EPI, W4_NoLg$ES64_EPI,
            W4_NoLg$AUTO_AVG, W4_NoLg$ES27_AVG, W4_NoLg$ES64_AVG
            )
)

# Create a new column for categories
combined_data <- combined_data %>%
  mutate(category = case_when(
    grepl("AR", Models) ~ "AR",
    grepl("EPI", Models) ~ "EPI",
    grepl("TMP", Models) ~ "TMP",
    grepl("ADJ", Models) ~ "ADJ",
    grepl("AVG", Models) ~ "AVG",
  ))

# Define color ramps for each category
colors_ar <- c("#a6cee3","#226e83", "#08306b")
colors_adj <- c("#fb9a99","red3", "#a11c3e")
colors_epi <- c("#cab2d6", "purple2", "#5e2b7b")
colors_tmp <- c("lightgreen","green3","#319045")
colors_avg <- c("orange","orange2", "orange3")

# Create a custom color mapping for each variable
custom_colors <- c(
  "AUTO_AR" = colors_ar[1], "ES27_AR" = colors_ar[2], "ES64_AR" = colors_ar[3],
  "AUTO_EPI" = colors_epi[1], "ES27_EPI" = colors_epi[2], "ES64_EPI" = colors_epi[3],
  "AUTO_TMP" = colors_tmp[1], "ES27_TMP" = colors_tmp[2], "ES64_TMP" = colors_tmp[3],
  "AUTO_ADJ" = colors_adj[1], "ES27_ADJ" = colors_adj[2], "ES64_ADJ" = colors_adj[3],
  "AUTO_AVG" = colors_avg[1], "ES27_AVG" = colors_avg[2], "ES64_AVG" = colors_avg[3]
)

# Create the box plot with facet for categories
plt1<-  ggplot(combined_data, aes(x = week, y = value, fill = Models)) +
    geom_boxplot(color = "black") +
    scale_fill_manual(values = custom_colors) +
    facet_wrap(category ~ Models , nrow = 5) +
    labs(
      title = "A) Models without log-back transformations",
      x = "",
      y = "Mean Weighted Interval Score (WIS)"
    ) +
  scale_y_continuous(limits = c(0, 650)) +  
    theme_minimal()+
  theme(legend.position = "none")
plt1
#ggsave(plt1, height = 12, width = 8, filename="fig1A.jpg")  
```

Loading model with log-back transformations.

```{r}
load("NHSH_hospitalizations_seed/ES_ARIMA/ARIMA_MODELS_influenza_hospitalization.Rdata")
load("NHSH_hospitalizations_seed/ES_ADJACENT/ADJACENT_MODELS_influenza_hospitalization.Rdata")
load("NHSH_hospitalizations_seed/ES_EPIWEEK/EPIWEEK_MODELS_influenza_hospitalization.Rdata")
load("NHSH_hospitalizations_seed/ES_TEMPERATURE/TEMPERATURE_MODELS_influenza_hospitalization.Rdata")
load("NHSH_hospitalizations_seed/ES_AVERAGE/AVERAGE_MODELS_influenza_hospitalization.Rdata")
```

------------
1 Week ahead
------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK1$epiweek <- MMWRweek(AUTO_ARIMA_WEEK1$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK1$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK1$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK1$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK1$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK1$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK1$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES27_ARIMA_WEEK1$epiweek <- MMWRweek(ES27_ARIMA_WEEK1$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK1$epiweek <- MMWRweek(ES27_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK1$epiweek <- MMWRweek(ES27_AVERAGE_WEEK1$target_end_date)$MMWRweek

ES64_ARIMA_WEEK1$epiweek <- MMWRweek(ES64_ARIMA_WEEK1$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK1$epiweek <- MMWRweek(ES64_ADJACENT_WEEK1$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK1$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK1$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK1$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK1$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK1$epiweek <- MMWRweek(ES64_AVERAGE_WEEK1$target_end_date)$MMWRweek

# Dataframe that will be analysed for 1 Week Ahead
df_W1 <- data.frame(
  STATE = AUTO_ARIMA_WEEK1$State,
  Julian_date = AUTO_ARIMA_WEEK1$target_end_date,
  epiweek = AUTO_ARIMA_WEEK1$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK1$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK1$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK1$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK1$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK1$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK1$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK1$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK1$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK1$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK1$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK1$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK1$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK1$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK1$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK1$WIS  
)

head(df_W1)
```

------------
2 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK2$epiweek <- MMWRweek(AUTO_ARIMA_WEEK2$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK2$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK2$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK2$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK2$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK2$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK2$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES27_ARIMA_WEEK2$epiweek <- MMWRweek(ES27_ARIMA_WEEK2$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK2$epiweek <- MMWRweek(ES27_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK2$epiweek <- MMWRweek(ES27_AVERAGE_WEEK2$target_end_date)$MMWRweek

ES64_ARIMA_WEEK2$epiweek <- MMWRweek(ES64_ARIMA_WEEK2$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK2$epiweek <- MMWRweek(ES64_ADJACENT_WEEK2$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK2$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK2$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK2$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK2$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK2$epiweek <- MMWRweek(ES64_AVERAGE_WEEK2$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Week Ahead
df_W2 <- data.frame(
  STATE = AUTO_ARIMA_WEEK2$State,
  Julian_date = AUTO_ARIMA_WEEK2$target_end_date,
  epiweek = AUTO_ARIMA_WEEK2$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK2$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK2$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK2$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK2$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK2$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK2$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK2$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK2$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK2$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK2$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK2$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK2$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK2$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK2$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK2$WIS  
)

head(df_W2)
```

-------------
3 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK3$epiweek <- MMWRweek(AUTO_ARIMA_WEEK3$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK3$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK3$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK3$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK3$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK3$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK3$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES27_ARIMA_WEEK3$epiweek <- MMWRweek(ES27_ARIMA_WEEK3$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK3$epiweek <- MMWRweek(ES27_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK3$epiweek <- MMWRweek(ES27_AVERAGE_WEEK3$target_end_date)$MMWRweek

ES64_ARIMA_WEEK3$epiweek <- MMWRweek(ES64_ARIMA_WEEK3$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK3$epiweek <- MMWRweek(ES64_ADJACENT_WEEK3$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK3$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK3$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK3$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK3$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK3$epiweek <- MMWRweek(ES64_AVERAGE_WEEK3$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Week Ahead
df_W3 <- data.frame(
  STATE = AUTO_ARIMA_WEEK3$State,
  Julian_date = AUTO_ARIMA_WEEK3$target_end_date,
  epiweek = AUTO_ARIMA_WEEK3$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK3$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK3$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK3$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK3$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK3$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK3$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK3$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK3$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK3$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK3$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK3$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK3$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK3$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK3$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK3$WIS  
)

head(df_W3)

```

-------------
4 Weeks ahead
-------------
```{r}
# Creating new columns with Epidemiological weeks based on target_end_week
AUTO_ARIMA_WEEK4$epiweek <- MMWRweek(AUTO_ARIMA_WEEK4$target_end_date)$MMWRweek
AUTO_ADJACENT_WEEK4$epiweek <- MMWRweek(AUTO_ADJACENT_WEEK4$target_end_date)$MMWRweek
AUTO_EPIWEEK_WEEK4$epiweek <- MMWRweek(AUTO_EPIWEEK_WEEK4$target_end_date)$MMWRweek
AUTO_TEMPERATURE_WEEK4$epiweek <- MMWRweek(AUTO_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
AUTO_AVERAGE_WEEK4$epiweek <- MMWRweek(AUTO_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES27_ARIMA_WEEK4$epiweek <- MMWRweek(ES27_ARIMA_WEEK4$target_end_date)$MMWRweek
ES27_ADJACENT_WEEK4$epiweek <- MMWRweek(ES27_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES27_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES27_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES27_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES27_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES27_AVERAGE_WEEK4$epiweek <- MMWRweek(ES27_AVERAGE_WEEK4$target_end_date)$MMWRweek

ES64_ARIMA_WEEK4$epiweek <- MMWRweek(ES64_ARIMA_WEEK4$target_end_date)$MMWRweek
ES64_ADJACENT_WEEK4$epiweek <- MMWRweek(ES64_ADJACENT_WEEK4$target_end_date)$MMWRweek
ES64_EPIWEEK_WEEK4$epiweek <- MMWRweek(ES64_EPIWEEK_WEEK4$target_end_date)$MMWRweek
ES64_TEMPERATURE_WEEK4$epiweek <- MMWRweek(ES64_TEMPERATURE_WEEK4$target_end_date)$MMWRweek
ES64_AVERAGE_WEEK4$epiweek <- MMWRweek(ES64_AVERAGE_WEEK4$target_end_date)$MMWRweek

# Dataframe that will be analysed for 2 Week Ahead
df_W4 <- data.frame(
  STATE = AUTO_ARIMA_WEEK4$State,
  Julian_date = AUTO_ARIMA_WEEK4$target_end_date,
  epiweek = AUTO_ARIMA_WEEK4$epiweek,
  AUTO_AR_LB=AUTO_ARIMA_WEEK4$WIS, 
  AUTO_ADJ_LB=AUTO_ADJACENT_WEEK4$WIS, 
  AUTO_EPI_LB=AUTO_EPIWEEK_WEEK4$WIS,
  AUTO_TEMP_LB=AUTO_TEMPERATURE_WEEK4$WIS,
  AUTO_AVG_LB=AUTO_AVERAGE_WEEK4$WIS,
  
  ES27_AR_LB=ES27_ARIMA_WEEK4$WIS, 
  ES27_ADJ_LB=ES27_ADJACENT_WEEK4$WIS, 
  ES27_EPI_LB=ES27_EPIWEEK_WEEK4$WIS,
  ES27_TEMP_LB=ES27_TEMPERATURE_WEEK4$WIS,
  ES27_AVG_LB=ES27_AVERAGE_WEEK4$WIS,  
  
  ES64_AR_LB=ES64_ARIMA_WEEK4$WIS, 
  ES64_ADJ_LB=ES64_ADJACENT_WEEK4$WIS, 
  ES64_EPI_LB=ES64_EPIWEEK_WEEK4$WIS,
  ES64_TEMP_LB=ES64_TEMPERATURE_WEEK4$WIS,
  ES64_AVG_LB=ES64_AVERAGE_WEEK4$WIS  
)

head(df_W4)
```

Filter only the flu season

```{r}
# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W1 <- df_W1 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W1)


# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W2 <- df_W2 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W2)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W3 <- df_W3 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W3)

# Filter the dataframe for epiweek >= 40 or epiweek <= 20
filtered_df_W4 <- df_W4 %>%
  filter(epiweek >= 40 | epiweek <= 20)

# Display the filtered dataset
head(filtered_df_W4)
```

Fitting data.

```{r}
i  <- 57 # forecasted week
ii <- 8 # state number

my_data = read.csv("NHSH_hospitalizations_seed/treated_influenza_hosp_dataframe_v2.csv")
my_data$target_end_date<-as.Date(my_data$target_end_date) # set the dates as dates

list_of_states <- split(my_data, my_data$state_name)

# Define the date range
end_date <- as.Date(AUTO_AVERAGE_WEEK1_list[[ii]]$target_end_date[i]-7)
start_date <- end_date - (7*103)  # 2 years before

# Subset the data
subset_data <- subset(list_of_states[[ii]], 
                      target_end_date >= start_date & target_end_date <= end_date)

# Plot
plot(subset_data$target_end_date, subset_data$cases, type = "l",
     xlab = "Date", ylab = "Cases", main = "Cases - Last 2 Years")
```

```{r}
i  <- 57 # forecast week
ii <- 8 # state number


forecast_df <- data.frame(
  Dates = c(
    AUTO_AVERAGE_WEEK1_list[[ii]]$target_end_date[i],
    AUTO_AVERAGE_WEEK2_list[[ii]]$target_end_date[i],
    AUTO_AVERAGE_WEEK3_list[[ii]]$target_end_date[i],
    AUTO_AVERAGE_WEEK4_list[[ii]]$target_end_date[i]
  ),
  Hosp  = c(
    AUTO_AVERAGE_WEEK1_list[[ii]]$cases[i],
    AUTO_AVERAGE_WEEK2_list[[ii]]$cases[i],
    AUTO_AVERAGE_WEEK3_list[[ii]]$cases[i],
    AUTO_AVERAGE_WEEK4_list[[ii]]$cases[i]
  ),
  Value = c(
    AUTO_AVERAGE_WEEK1_list[[ii]]$forecasts[i],
    AUTO_AVERAGE_WEEK2_list[[ii]]$forecasts[i],
    AUTO_AVERAGE_WEEK3_list[[ii]]$forecasts[i],
    AUTO_AVERAGE_WEEK4_list[[ii]]$forecasts[i]
  ),
  Lower = c(
    AUTO_AVERAGE_WEEK1_list[[ii]][["0.025"]][i],
    AUTO_AVERAGE_WEEK2_list[[ii]][["0.025"]][i],
    AUTO_AVERAGE_WEEK3_list[[ii]][["0.025"]][i],
    AUTO_AVERAGE_WEEK4_list[[ii]][["0.025"]][i]
  ),
  Upper = c(
    AUTO_AVERAGE_WEEK1_list[[ii]][["0.975"]][i],
    AUTO_AVERAGE_WEEK2_list[[ii]][["0.975"]][i],
    AUTO_AVERAGE_WEEK3_list[[ii]][["0.975"]][i],
    AUTO_AVERAGE_WEEK4_list[[ii]][["0.975"]][i]
  )
)

conceptual_figure = ggplot() +
  # two-year fitting data
  geom_point(data = subset_data, 
            aes(x = target_end_date, y = cases, color = "Fitting data"), 
            size = 2.5) +
  # grey ribbon 
  geom_ribbon(data = forecast_df, 
              aes(x = Dates, ymin = Lower, ymax = Upper), 
              fill = "gray", alpha = 0.4) +
  # mean forecast 
  geom_point(data = forecast_df, 
            aes(x = Dates, y = Value, color = "Mean forecast"), 
             size = 3) +
  
  geom_point(data = forecast_df, 
             aes(x = Dates, y = Value, color = "Mean forecast"), 
             shape = 21, fill = "white", size = 2) +
  # actual hospitalizations 
  geom_point(data = forecast_df, 
             aes(x = Dates, y = Hosp, color = "Hospitalizations"), 
             shape = 16, size = 2.5) +
  # Manually define legend entries
  scale_color_manual(name = "Legend",
                     values = c("Fitting data" = "red", 
                                "Mean forecast" = "cyan3",
                                "Hospitalizations" = "black")) +
    scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %y"
  ) +
  
  labs(
    title    = "Example of probabilistic forecasts",
    subtitle = "Gray ribbon represents 95% confidence interval",
    x        = "",
    y        = "Hospitalizations"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),
    axis.text.x = element_text(angle = 45, hjust = 1))

conceptual_figure
# Save the combined plot
ggsave("Fig1.jpg", conceptual_figure, width = 7, height = 4, dpi = 600)

```
Evaluating other forecasts

```{r}
plot_forecast <- function(i, ii,
                          list_of_states,
                          AUTO_AVERAGE_WEEK1_list,
                          AUTO_AVERAGE_WEEK2_list,
                          AUTO_AVERAGE_WEEK3_list,
                          AUTO_AVERAGE_WEEK4_list) {

  # Define date range for 2-year history
  end_date <- as.Date(AUTO_AVERAGE_WEEK1_list[[ii]]$target_end_date[i] - 7)
  start_date <- end_date - (7 * 103)

  # Subset observed data
  subset_data <- subset(list_of_states[[ii]],
                        target_end_date >= start_date & target_end_date <= end_date)

  # Build forecast dataframe
  forecast_df <- data.frame(
    Dates = c(
      AUTO_AVERAGE_WEEK1_list[[ii]]$target_end_date[i],
      AUTO_AVERAGE_WEEK2_list[[ii]]$target_end_date[i],
      AUTO_AVERAGE_WEEK3_list[[ii]]$target_end_date[i],
      AUTO_AVERAGE_WEEK4_list[[ii]]$target_end_date[i]
    ),
    Hosp = c(
      AUTO_AVERAGE_WEEK1_list[[ii]]$cases[i],
      AUTO_AVERAGE_WEEK2_list[[ii]]$cases[i],
      AUTO_AVERAGE_WEEK3_list[[ii]]$cases[i],
      AUTO_AVERAGE_WEEK4_list[[ii]]$cases[i]
    ),
    Value = c(
      AUTO_AVERAGE_WEEK1_list[[ii]]$forecasts[i],
      AUTO_AVERAGE_WEEK2_list[[ii]]$forecasts[i],
      AUTO_AVERAGE_WEEK3_list[[ii]]$forecasts[i],
      AUTO_AVERAGE_WEEK4_list[[ii]]$forecasts[i]
    ),
    Lower = c(
      AUTO_AVERAGE_WEEK1_list[[ii]][["0.025"]][i],
      AUTO_AVERAGE_WEEK2_list[[ii]][["0.025"]][i],
      AUTO_AVERAGE_WEEK3_list[[ii]][["0.025"]][i],
      AUTO_AVERAGE_WEEK4_list[[ii]][["0.025"]][i]
    ),
    Upper = c(
      AUTO_AVERAGE_WEEK1_list[[ii]][["0.975"]][i],
      AUTO_AVERAGE_WEEK2_list[[ii]][["0.975"]][i],
      AUTO_AVERAGE_WEEK3_list[[ii]][["0.975"]][i],
      AUTO_AVERAGE_WEEK4_list[[ii]][["0.975"]][i]
    )
  )

  # Build the plot
  ggplot() +
    geom_point(data = subset_data,
               aes(x = target_end_date, y = cases, color = "Fitting data"),
               size = 2.5) +
    geom_ribbon(data = forecast_df,
                aes(x = Dates, ymin = Lower, ymax = Upper),
                fill = "gray", alpha = 0.4) +
    geom_point(data = forecast_df,
               aes(x = Dates, y = Value, color = "Mean forecast"),
               size = 3) +
    geom_point(data = forecast_df,
               aes(x = Dates, y = Value, color = "Mean forecast"),
               shape = 21, fill = "white", size = 2) +
    geom_point(data = forecast_df,
               aes(x = Dates, y = Hosp, color = "Hospitalizations"),
               shape = 16, size = 2.5) +
    scale_color_manual(name = "Legend",
                       values = c("Fitting data" = "red",
                                  "Mean forecast" = "cyan3",
                                  "Hospitalizations" = "black")) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %y") +
    labs(title = paste("State:", names(list_of_states)[ii], "- Week Index:", i),
         subtitle = "Gray ribbon represents 95% confidence interval",
         x = "", y = "Hospitalizations") +
    theme_minimal() +
    theme(plot.title = element_text(size = 18, face = "bold"),
          plot.subtitle = element_text(size = 14),
          axis.text.x = element_text(angle = 45, hjust = 1))
}

for (ii in 1:48) {
  for (i in 60:70) {
    # Safely check if index exists
    if (i <= nrow(AUTO_AVERAGE_WEEK1_list[[ii]])) {
      p <- plot_forecast(i, ii,
                         list_of_states,
                         AUTO_AVERAGE_WEEK1_list,
                         AUTO_AVERAGE_WEEK2_list,
                         AUTO_AVERAGE_WEEK3_list,
                         AUTO_AVERAGE_WEEK4_list)
      # Show the plot
      print(p)
    }
  }
}

```

Calculate mean weighted interval score for influenza seasons on each model and each state.

```{r}

# Define the function
calculate_mean_wis <- function(data) {
  data %>%
    group_by(STATE) %>%
    summarize(
      AUTO_AR_LB = mean(AUTO_AR_LB, na.rm = TRUE),
      AUTO_ADJ_LB = mean(AUTO_ADJ_LB, na.rm = TRUE),
      AUTO_EPI_LB = mean(AUTO_EPI_LB, na.rm = TRUE),
      AUTO_TMP_LB = mean(AUTO_TEMP_LB, na.rm = TRUE),
      AUTO_AVG_LB = mean(AUTO_AVG_LB, na.rm = TRUE),
      
      ES27_AR_LB = mean(ES27_AR_LB, na.rm = TRUE),
      ES27_ADJ_LB = mean(ES27_ADJ_LB, na.rm = TRUE),
      ES27_EPI_LB = mean(ES27_EPI_LB, na.rm = TRUE),
      ES27_TMP_LB = mean(ES27_TEMP_LB, na.rm = TRUE),
      ES27_AVG_LB = mean(ES27_AVG_LB, na.rm = TRUE),
      
      ES64_AR_LB = mean(ES64_AR_LB, na.rm = TRUE),
      ES64_ADJ_LB = mean(ES64_ADJ_LB, na.rm = TRUE),
      ES64_EPI_LB = mean(ES64_EPI_LB, na.rm = TRUE),
      ES64_TMP_LB = mean(ES64_TEMP_LB, na.rm = TRUE),
      ES64_AVG_LB = mean(ES64_AVG_LB, na.rm = TRUE),
    )
}

# Now we can use the function with any dataframe
W1_Lg <- calculate_mean_wis(filtered_df_W1)
W2_Lg <- calculate_mean_wis(filtered_df_W2)
W3_Lg <- calculate_mean_wis(filtered_df_W3)
W4_Lg <- calculate_mean_wis(filtered_df_W4)

# Display the resulting dataframe
head(W1_Lg)
head(W2_Lg)
head(W3_Lg)
head(W4_Lg)
```

Here we have boxplots of the mean(WIS) by each state. 

```{r}
# Combine the data into one dataframe
combined_data <- data.frame(
  week = rep(c("W1", "W2", "W3", "W4"), each = 48 * 15),
  
  Models = rep(c("AUTO_AR_LB", "ES27_AR_LB", "ES64_AR_LB", "AUTO_ADJ_LB", "ES27_ADJ_LB", "ES64_ADJ_LB", "AUTO_TMP_LB", "ES27_TMP_LB", "ES64_TMP_LB", "AUTO_EPI_LB", "ES27_EPI_LB", "ES64_EPI_LB", "AUTO_AVG_LB", "ES27_AVG_LB", "ES64_AVG_LB"), each=48, times = 4),
  
  value = c(W1_Lg$AUTO_AR_LB, W1_Lg$ES27_AR_LB, W1_Lg$ES64_AR_LB, 
            W1_Lg$AUTO_ADJ_LB, W1_Lg$ES27_ADJ_LB, W1_Lg$ES64_ADJ_LB, 
            W1_Lg$AUTO_TMP_LB, W1_Lg$ES27_TMP_LB, W1_Lg$ES64_TMP_LB, 
            W1_Lg$AUTO_EPI_LB, W1_Lg$ES27_EPI_LB, W1_Lg$ES64_EPI_LB,
            W1_Lg$AUTO_AVG_LB, W1_Lg$ES27_AVG_LB, W1_Lg$ES64_AVG_LB,
            
            W2_Lg$AUTO_AR_LB, W2_Lg$ES27_AR_LB, W2_Lg$ES64_AR_LB, 
            W2_Lg$AUTO_ADJ_LB, W2_Lg$ES27_ADJ_LB, W2_Lg$ES64_ADJ_LB, 
            W2_Lg$AUTO_TMP_LB, W2_Lg$ES27_TMP_LB, W2_Lg$ES64_TMP_LB, 
            W2_Lg$AUTO_EPI_LB, W2_Lg$ES27_EPI_LB, W2_Lg$ES64_EPI_LB,
            W2_Lg$AUTO_AVG_LB, W2_Lg$ES27_AVG_LB, W2_Lg$ES64_AVG_LB,            
            
            W3_Lg$AUTO_AR_LB, W3_Lg$ES27_AR_LB, W3_Lg$ES64_AR_LB, 
            W3_Lg$AUTO_ADJ_LB, W3_Lg$ES27_ADJ_LB, W3_Lg$ES64_ADJ_LB, 
            W3_Lg$AUTO_TMP_LB, W3_Lg$ES27_TMP_LB, W3_Lg$ES64_TMP_LB, 
            W3_Lg$AUTO_EPI_LB, W3_Lg$ES27_EPI_LB, W3_Lg$ES64_EPI_LB,
            W3_Lg$AUTO_AVG_LB, W3_Lg$ES27_AVG_LB, W3_Lg$ES64_AVG_LB,
            
            W4_Lg$AUTO_AR_LB, W4_Lg$ES27_AR_LB, W4_Lg$ES64_AR_LB, 
            W4_Lg$AUTO_ADJ_LB, W4_Lg$ES27_ADJ_LB, W4_Lg$ES64_ADJ_LB, 
            W4_Lg$AUTO_TMP_LB, W4_Lg$ES27_TMP_LB, W4_Lg$ES64_TMP_LB, 
            W4_Lg$AUTO_EPI_LB, W4_Lg$ES27_EPI_LB, W4_Lg$ES64_EPI_LB,
            W4_Lg$AUTO_AVG_LB, W4_Lg$ES27_AVG_LB, W4_Lg$ES64_AVG_LB)
)

# Create a new column for model families
combined_data <- combined_data %>%
  mutate(category = case_when(
    grepl("AR", Models) ~ "AR",
    grepl("EPI", Models) ~ "EPI",
    grepl("TMP", Models) ~ "TMP",
    grepl("ADJ", Models) ~ "ADJ",
    grepl("AVG", Models) ~ "AVG",
  ))

# Define color ramps for each model family
colors_ar <- c("#a6cee3","#226e83", "#08306b")
colors_adj <- c("#fb9a99","red3", "#a11c3e")
colors_epi <- c("#cab2d6", "purple2", "#5e2b7b")
colors_tmp <- c("lightgreen","green3","#319045")
colors_avg <- c("orange","orange2", "orange3")

# Use a custom color on each model
custom_colors <- c(
  "AUTO_AR_LB" = colors_ar[1], "ES27_AR_LB" = colors_ar[2], "ES64_AR_LB" = colors_ar[3],
  "AUTO_EPI_LB" = colors_epi[1], "ES27_EPI_LB" = colors_epi[2], "ES64_EPI_LB" = colors_epi[3],
  "AUTO_TMP_LB" = colors_tmp[1], "ES27_TMP_LB" = colors_tmp[2], "ES64_TMP_LB" = colors_tmp[3],
  "AUTO_ADJ_LB" = colors_adj[1], "ES27_ADJ_LB" = colors_adj[2], "ES64_ADJ_LB" = colors_adj[3],
  "AUTO_AVG_LB" = colors_avg[1], "ES27_AVG_LB" = colors_avg[2], "ES64_AVG_LB" = colors_avg[3]
)

# Create the box plot with additional facet for categories
plt2<-  ggplot(combined_data, aes(x = week, y = value, fill = Models)) +
    geom_boxplot(color = "black") +
    scale_fill_manual(values = custom_colors) +
    facet_wrap(category ~ Models , nrow = 5) +
    labs(
      title = "B) Models with log-back transformations",
      x = "",
      y = "Weighted Interval Score (WIS)"
    ) +
  scale_y_continuous(limits = c(0, 650)) +  # Set y-axis range
    theme_minimal()+
  theme(legend.position = "none")
plt2
#ggsave(plt2, height = 8, width = 10, filename="Fig1B.jpg")  
```
Figure 3

```{r}
# Combine plot in a 2x2 grid
figure3 <- (plt1 | plt2) + 
  plot_annotation(
    title = "Mean WIS for the 24 models",
    subtitle = "Results by target week",
    theme = theme(plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))
  )
# Print
print(figure3) 

# Save to file
ggsave("Fig3.jpg", figure3, width =9, height =10)
```

COMBINING THE RESULTS WITH LOG-BACK AND NO LOG-BACK TRASNFORMATION

```{r}
W1<-merge(W1_Lg,W1_NoLg, by = "STATE")
W2<-merge(W2_Lg,W2_NoLg, by = "STATE")
W3<-merge(W3_Lg,W3_NoLg, by = "STATE")
W4<-merge(W4_Lg,W4_NoLg, by = "STATE")
```

Here I include a column with the best model based on the lowest mean(WIS) of each state.

```{r}
# BEST RESULT

cols <- colnames(W1)[-1] # get states names
W1$Best_Result <- character(nrow(W1)) # create an empty column for the best models

# Give me the model with lower WIS value 
for (i in 1:nrow(W1)) {
  # Find the model with the minimum value on each row
  # based on the column name
  # save it in the best result
  W1$Best_Result[i] <- cols[which.min(W1[i, cols])]
}

# REORDER BY FREQUENCY
W1$Best_Result <- fct_infreq(W1$Best_Result)
# Create a new column to indicate if model has a log-back
# transformation or not
W1$Model_Type <- ifelse(grepl("_LB$", W1$Best_Result), "With log-back transformation", "Without log-back transformation")

# Print the first rows
head(W1)

################################################

# Extract the columns of interest 
cols <- colnames(W2)[-1]  # get states names
W2$Best_Result <- character(nrow(W2)) # create an empty column for the best models
# Give me the model with lower WIS value 
for (i in 1:nrow(W2)) {
  # Find the model with the minimum value on each row
  # based on the column name
  # save it in the best result
  W2$Best_Result[i] <- cols[which.min(W2[i, cols])]
}

# REORDER BY FREQUENCY
W2$Best_Result <- fct_infreq(W2$Best_Result)
# Create a new column to indicate if model has a log-back
# transformation or not
W2$Model_Type <- ifelse(grepl("_LB$", W2$Best_Result),  "With log-back transformation","Without log-back transformation")

# Print merged results
head(W2)

######################################
# BEST RESULT
# Extract the columns of interest 
cols <- colnames(W3)[-1] # get states names
W3$Best_Result <- character(nrow(W3))# create an empty column for the best models
# Give me the model with lower WIS value
for (i in 1:nrow(W3)) {
  # Find the model with the minimum value on each row
  # based on the column name
  # save it in the best result
  W3$Best_Result[i] <- cols[which.min(W3[i, cols])]
}

# REORDER BY FREQUENCY
W3$Best_Result <- fct_infreq(W3$Best_Result)
# Create a new column to indicate if model has a log-back
# transformation or not
W3$Model_Type <- ifelse(grepl("_LB$", W3$Best_Result),  "With log-back transformation","Without log-back transformation")

# Print merged results
head(W3)

###################################
# BEST RESULT
# Extract the columns of interest 
cols <- colnames(W4)[-1] # get states names
W4$Best_Result <- character(nrow(W4)) # create an empty column for the best models

# Give me the model with lower WIS value
for (i in 1:nrow(W4)) {
  # Find the model with the minimum value on each row
  # based on the column name
  # save it in the best result
  W4$Best_Result[i] <- cols[which.min(W4[i, cols])]
}
W4$Best_Result <- fct_infreq(W4$Best_Result)
# Create a new column to indicate if model has a log-back
# transformation or not
W4$Model_Type <- ifelse(grepl("_LB$", W4$Best_Result),  "With log-back transformation","Without log-back transformation")
# Print merged results
head(W4)

```

Now, let's plot the best models by each state for each forecast horizon (1-4 weeks ahead). 

```{r}

# define colors for the plot
custom_colors <- c(
  "AUTO_AR_LB" = colors_ar[1], "ES27_AR_LB" = colors_ar[1], "ES64_AR_LB" = colors_ar[1],
  "AUTO_EPI_LB" = colors_epi[1], "ES27_EPI_LB" = colors_epi[1], "ES64_EPI_LB" = colors_epi[1],
  "AUTO_TMP_LB" = colors_tmp[1], "ES27_TMP_LB" = colors_tmp[1], "ES64_TMP_LB" = colors_tmp[1],
  "AUTO_ADJ_LB" = colors_adj[1], "ES27_ADJ_LB" = colors_adj[1], "ES64_ADJ_LB" = colors_adj[1],
  "AUTO_AVG_LB" = colors_avg[1], "ES27_AVG_LB" = colors_avg[1], "ES64_AVG_LB" = colors_avg[1],
  
  
  "AUTO_AR" = colors_ar[1], "ES27_AR" = colors_ar[1], "ES64_AR" = colors_ar[1],
  "AUTO_EPI" = colors_epi[1], "ES27_EPI" = colors_epi[1], "ES64_EPI" = colors_epi[1],
  "AUTO_TMP" = colors_tmp[1], "ES27_TMP" = colors_tmp[1], "ES64_TMP" = colors_tmp[1],
  "AUTO_ADJ" = colors_adj[1], "ES27_ADJ" = colors_adj[1], "ES64_ADJ" = colors_adj[1],
  "AUTO_AVG" = colors_avg[1], "ES27_AVG" = colors_avg[1], "ES64_AVG" = colors_avg[1]
)

# define patterns for the plot
custom_patterns <- c(
  # AR
  "AUTO_AR"      = "circle",      "AUTO_AR_LB"      = "circle",
  "ES27_AR"      = "stripe",      "ES27_AR_LB"      = "stripe",
  "ES64_AR"      = "crosshatch",  "ES64_AR_LB"      = "crosshatch",
  # EPI
  "AUTO_EPI"     = "circle",      "AUTO_EPI_LB"     = "circle",
  "ES27_EPI"     = "stripe",      "ES27_EPI_LB"     = "stripe",
  "ES64_EPI"     = "crosshatch",  "ES64_EPI_LB"     = "crosshatch",
  # TMP
  "AUTO_TMP"     = "circle",      "AUTO_TMP_LB"     = "circle",
  "ES27_TMP"     = "stripe",      "ES27_TMP_LB"     = "stripe",
  "ES64_TMP"     = "crosshatch",  "ES64_TMP_LB"     = "crosshatch",
  # ADJ
  "AUTO_ADJ"     = "circle",      "AUTO_ADJ_LB"     = "circle",
  "ES27_ADJ"     = "stripe",      "ES27_ADJ_LB"     = "stripe",
  "ES64_ADJ"     = "crosshatch",  "ES64_ADJ_LB"     = "crosshatch",
  # AVG
  "AUTO_AVG"     = "circle",      "AUTO_AVG_LB"     = "circle",
  "ES27_AVG"     = "stripe",      "ES27_AVG_LB"     = "stripe",
  "ES64_AVG"     = "crosshatch",  "ES64_AVG_LB"     = "crosshatch"
)

plot1 <- ggplot(W1, aes(x = Best_Result,
                        pattern = Best_Result,
                        fill    = Best_Result)) +
  geom_bar_pattern(
    colour        = NA,         
    pattern_fill  = "black",
    pattern_size  = 0.2,
    pattern_angle = 45          
  ) +
  scale_fill_manual(values   = custom_colors) +
  scale_pattern_manual(values = custom_patterns) +
  labs(title = "Best model on the 48 U.S. states (W1)",
       x = NULL, y = "Number of states") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ Model_Type, scales = "free_x") 

plot1

plot2 <- ggplot(W2, aes(x = Best_Result,
                        pattern = Best_Result,
                        fill    = Best_Result)) +
  geom_bar_pattern(
    colour        = NA,         
    pattern_fill  = "black",
    pattern_size  = 0.2,
    pattern_angle = 45          
  ) +
  scale_fill_manual(values   = custom_colors) +
  scale_pattern_manual(values = custom_patterns) +
  labs(title = "Best model on the 48 U.S. states (W2)",
       x = NULL, y = "Number of states") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ Model_Type, scales = "free_x")

plot2

plot3 <- ggplot(W3, aes(x = Best_Result,
                        pattern = Best_Result,
                        fill    = Best_Result)) +
  geom_bar_pattern(
    colour        = NA,           
    pattern_fill  = "black",
    pattern_size  = 0.2,
    pattern_angle = 45      
  ) +
  scale_fill_manual(values   = custom_colors) +
  scale_pattern_manual(values = custom_patterns) +
  labs(title = "Best model on the 48 U.S. states (W3)",
       x = NULL, y = "Number of states") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ Model_Type, scales = "free_x") 
plot3

plot4 <- ggplot(W4, aes(x = Best_Result,
                        pattern = Best_Result,
                        fill    = Best_Result)) +
  geom_bar_pattern(
    colour        = NA,       
    pattern_fill  = "black",
    pattern_size  = 0.2,
    pattern_angle = 45          
  ) +
  scale_fill_manual(values   = custom_colors) +
  scale_pattern_manual(values = custom_patterns) +
  labs(title = "Best model on the 48 U.S. states (W4)",
       x = NULL, y = "Number of states") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ Model_Type, scales = "free_x") 
plot4
```

Now I will combine all these plots 2x2.

```{r}
# Include columns with target week labels
W1$Week_Ahead <- "W1"
W2$Week_Ahead <- "W2"
W3$Week_Ahead <- "W3"
W4$Week_Ahead <- "W4"

# Combine all dataframes
all_weeks <- bind_rows(W1, W2, W3, W4)

# Create combined plot
combined_plot <- ggplot(all_weeks, aes(x = Best_Result, 
                                       fill = Best_Result,
                                       pattern = Best_Result)) +
  geom_bar_pattern(
    pattern_fill  = "black",
    pattern_size  = 0.1,
    pattern_angle = 45,  
    colour        = NA
  ) +
  scale_fill_manual(values = custom_colors) +
  scale_pattern_manual(values = custom_patterns) +
  labs(title = "Best model based on the lowest mean WIS",
       subtitle = "Results for the 48 states on the contiguous U.S. by target week",
       x = "", y = "Number of states",
       fill = "Best model",
       pattern = "Best model") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 16, face = "bold"),legend.position = "left") +
  facet_grid(Week_Ahead ~ Model_Type, scales = "free_x") 

# Save and display the plot
#ggsave("Fig4.jpg", combined_plot, width = 7, height = 6)
print(combined_plot)

```
These legends from ggplot don't work well. I will create an legend for a random plot and I will use this legend in the previous plot.

```{r}

# Define the custom patterns
custom_patterns <- c("AUTO" = "circle", "ES27" = "stripe", "ES64" = "crosshatch")
custom_fills <- c("AUTO" = "white", "ES27" = "white", "ES64" = "white") 

# Create a example of plot
legend_data <- data.frame(
  Model_Type = c("AUTO", "ES27", "ES64", "ES27", "ES64"),
  Model_Family = c("AR","TMP", "EPI", "ADJ","AVG"),
  x = 1:5,
  y = 1
)

# Define patterns for model types
custom_patterns <- c("AUTO" = "circle", "ES27" = "stripe", "ES64" = "crosshatch")

# Define colors
custom_fills <- c("AR" = colors_ar[1], "TMP"=colors_tmp[1], "EPI" = colors_epi[1], "ADJ" = colors_adj[1], "AVG" = colors_avg[1])

# Visualizing an example
custom_legend <- ggplot(legend_data, aes(x = factor(x), y = y, 
                                         pattern = Model_Type, fill = Model_Family)) +
  geom_bar_pattern(stat = "identity",
                   pattern_fill = "black",
                   pattern_density = 0.3,
                   pattern_spacing = 0.05,
                   pattern_size = 0.15,
                   colour = "black",
                   width = 0.7) +
  scale_fill_manual(values = custom_fills, name = "Model Family") +
  scale_pattern_manual(values = custom_patterns, name = "Model Type") +
  theme_void() +
  theme(
    legend.position = "right",
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10)
  ) +
  guides(
    fill = guide_legend(
      override.aes = list(pattern = "none", pattern_fill = NA, colour = NA)
    ),
    pattern = guide_legend(
      override.aes = list(fill = "white", pattern_fill = "black")
    )
  )
custom_legend
```
Here is the final plot with custom legend.

```{r}

# Remove legends from initial plot
combined_plot_clean <- combined_plot + theme(legend.position = "none")

# Extract only the custom legend
legend_only <- cowplot::get_legend(custom_legend)

# Combine your main plot with the custom legend
figure4 <- combined_plot_clean + 
  patchwork::plot_spacer() + 
  patchwork::wrap_elements(legend_only) + 
  plot_layout(widths = c(4, 0.05, 0.4))  # Adjust widths as needed

# Display the result
figure4

ggsave("Fig4.jpg", figure4, width = 10, height = 6)

```

ERASE

```{r}
# Create a custom color mapping for each variable
custom_colors <- c(
  "AUTO_AR_LB" = colors_ar[1], "ES27_AR_LB" = colors_ar[2], "ES64_AR_LB" = colors_ar[3],
  "AUTO_EPI_LB" = colors_epi[1], "ES27_EPI_LB" = colors_epi[2], "ES64_EPI_LB" = colors_epi[3],
  "AUTO_TMP_LB" = colors_tmp[1], "ES27_TMP_LB" = colors_tmp[2], "ES64_TMP_LB" = colors_tmp[3],
  "AUTO_ADJ_LB" = colors_adj[1], "ES27_ADJ_LB" = colors_adj[2], "ES64_ADJ_LB" = colors_adj[3],
  "AUTO_AVG_LB" = colors_avg[1], "ES27_AVG_LB" = colors_avg[2], "ES64_AVG_LB" = colors_avg[3],
  
  
  "AUTO_AR" = colors_ar[1], "ES27_AR" = colors_ar[2], "ES64_AR" = colors_ar[3],
  "AUTO_EPI" = colors_epi[1], "ES27_EPI" = colors_epi[2], "ES64_EPI" = colors_epi[3],
  "AUTO_TMP" = colors_tmp[1], "ES27_TMP" = colors_tmp[2], "ES64_TMP" = colors_tmp[3],
  "AUTO_ADJ" = colors_adj[1], "ES27_ADJ" = colors_adj[2], "ES64_ADJ" = colors_adj[3],
  "AUTO_AVG" = colors_avg[1], "ES27_AVG" = colors_avg[2], "ES64_AVG" = colors_avg[3]
)

# --------- WEEK1 MODELS ------------- #
plot1<- ggplot(W1, aes(x = Best_Result, fill = Best_Result)) +  
  geom_bar() +  
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Best model on the 48 U.S. states (W1)",       
       x = "", y = "Number of states") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  facet_wrap(~ Model_Type, scales = "free_x")

plot1

#ggsave("week1_best_models.jpg", plot1)

# --------- WEEK2 MODELS ------------- #
plot2<-ggplot(W2, aes(x = Best_Result, fill = Best_Result))  +  
  geom_bar() +  
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Best model on the 48 U.S. states (W2)",       
       x = "", y = "Number of states") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  facet_wrap(~ Model_Type, scales = "free_x")

#ggsave("week2_best_models.jpg", plot2)

plot2

# --------- WEEK3 MODELS ------------- #
plot3<-ggplot(W3, aes(x = Best_Result, fill = Best_Result))  +  
  geom_bar() +  
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Best model on the 48 U.S. states (W3)",       
       x = "", y = "Number of states") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  facet_wrap(~ Model_Type, scales = "free_x")
plot3

#ggsave("week3_best_models.jpg", plot3)

# --------- WEEK4 MODELS ------------- #
plot4<-ggplot(W4, aes(x = Best_Result, fill = Best_Result)) +  
  geom_bar() +  
  scale_fill_manual(values = custom_colors) +  
  labs(title = "Best model on the 48 U.S. states (W4)",       
       x = "", y = "Number of states") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  facet_wrap(~ Model_Type, scales = "free_x")
plot4

#ggsave("week4_best_models.jpg", plot4)

```

ERASE

```{r}
# Add a column to indicate the week ahead
W1$Week_Ahead <- "W1"
W2$Week_Ahead <- "W2"
W3$Week_Ahead <- "W3"
W4$Week_Ahead <- "W4"

# Combine all weeks into one dataframe
all_weeks <- bind_rows(W1, W2, W3, W4)

# Create the plot
combined_plot <- ggplot(all_weeks, aes(x = Best_Result, fill = Best_Result)) +
  geom_bar() +
  scale_fill_manual(values = custom_colors) +
  labs(title = "Best model based on the lowest mean WIS",
       subtitle = "Results for the 48 states on the contiguous U.S. by target week",
       x = "", y = "Number of states",
       fill = "Best model" ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 16, face = "bold")) +
  facet_grid(Week_Ahead ~ Model_Type, scales = "free_x")

# Save and display the plot
#ggsave("Fig4.jpg", combined_plot, width =8, height =5)
print(combined_plot)

```
 
Now we use a Wilcox test with Holm p-value adjustment for repeated comparisons to evaluate the differences in model performances. 

1 WEEK AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Get all models names except baseline
model_types <- setdiff(names(W1), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against baseline
wilcox_results1 <- map_df(model_types, function(model) {
  test <- wilcox.test(W1[[model]], W1$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# p values adjustment
p_values<-wilcox_results1$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk1 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=1)
p_values_wk1 <-drop_na(p_values_wk1)
p_values_wk1

```

2 WEEKS AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Get all models names except baseline
model_types <- setdiff(names(W2), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against baseline
wilcox_results2 <- map_df(model_types, function(model) {
  test <- wilcox.test(W2[[model]], W2$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# p values adjustment
p_values<-wilcox_results2$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk2 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=2)
p_values_wk2 <-drop_na(p_values_wk2)
p_values_wk2
```

3 WEEKS AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Get all models names except baseline
model_types <- setdiff(names(W3), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against baseline
wilcox_results3 <- map_df(model_types, function(model) {
  test <- wilcox.test(W3[[model]], W3$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# p values adjustment
p_values<-wilcox_results3$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk3 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=3)
p_values_wk3 <-drop_na(p_values_wk3)
p_values_wk3
```

4 WEEKS AHEAD - Wilcoxon test with Holm p-value adjustment

```{r}
# Get all models names except baseline
model_types <- setdiff(names(W4), c("STATE", "AUTO_AR","Best_Result","Model_Type","Week_Ahead"))

# Perform Wilcoxon test for each model type against baseline
wilcox_results4 <- map_df(model_types, function(model) {
  test <- wilcox.test(W4[[model]], W4$AUTO_AR, paired = TRUE)
  data.frame(Model = model, p_value = test$p.value, W = test$statistic)
})

# Perform Wilcoxon test for each model type against AUTO_AAR
p_values<-wilcox_results4$p_value 
p_values<-p.adjust(p_values, method = "holm")
p_values<-data.frame(p_values)

#########################################################################
p_values_wk4 <- data.frame(Model = model_types, PValue = p_values, WeekAhead=4)
p_values_wk4 <-drop_na(p_values_wk4)
p_values_wk4

```

Let's calculate the mean(WIS) improvement relative to the AUTO ARIMA model. We will compare each model with the AUTO ARIMA model for the same states. Later we sum the results of these comparisons. Negative results indicate that there was a general improvement in the mean(WIS) for a given model type among all states. 

```{r}
calculate_percentage_of_improvement <- function(data) {
  return(data.frame(
    AUTO_AR = (((data$AUTO_AR / data$AUTO_AR)-1) * 100),
    ES27_AR = (((data$ES27_AR/data$AUTO_AR)-1) * 100),
    ES64_AR = (((data$ES64_AR/data$AUTO_AR )-1) * 100),
   
    AUTO_ADJ = (((data$AUTO_ADJ/data$AUTO_AR)-1) * 100),
    ES27_ADJ = (((data$ES27_ADJ/data$AUTO_AR)-1) * 100),
    ES64_ADJ = (((data$ES64_ADJ/data$AUTO_AR)-1) * 100),
    
    AUTO_TMP = (((data$AUTO_TMP/data$AUTO_AR)-1) * 100),
    ES27_TMP = (((data$ES27_TMP/data$AUTO_AR)-1) * 100),
    ES64_TMP = (((data$ES64_TMP/data$AUTO_AR)-1) * 100),
    
    AUTO_EPI = (((data$AUTO_EPI/data$AUTO_AR)-1) * 100),
    ES27_EPI = (((data$ES27_EPI/data$AUTO_AR)-1) * 100),
    ES64_EPI = (((data$ES64_EPI/data$AUTO_AR)-1) * 100),
    
    AUTO_AVG = (((data$AUTO_AVG/data$AUTO_AR)-1) * 100),
    ES27_AVG = (((data$ES27_AVG/data$AUTO_AR)-1) * 100),
    ES64_AVG = (((data$ES64_AVG/data$AUTO_AR)-1) * 100),
    
    AUTO_AR_LB = (((data$AUTO_AR_LB/data$AUTO_AR)-1) * 100),
    ES27_AR_LB = (((data$ES27_AR_LB/data$AUTO_AR)-1) * 100),
    ES64_AR_LB = (((data$ES64_AR_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_ADJ_LB = (((data$AUTO_ADJ_LB/data$AUTO_AR)-1) * 100),
    ES27_ADJ_LB = (((data$ES27_ADJ_LB/data$AUTO_AR)-1) * 100),
    ES64_ADJ_LB = (((data$ES64_ADJ_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_TMP_LB = (((data$AUTO_TMP_LB/data$AUTO_AR)-1) * 100),
    ES27_TMP_LB = (((data$ES27_TMP_LB/data$AUTO_AR)-1) * 100),
    ES64_TMP_LB = (((data$ES64_TMP_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_EPI_LB = (((data$AUTO_EPI_LB/data$AUTO_AR)-1) * 100),
    ES27_EPI_LB = (((data$ES27_EPI_LB/data$AUTO_AR)-1) * 100),
    ES64_EPI_LB = (((data$ES64_EPI_LB/data$AUTO_AR)-1) * 100),
    
    AUTO_AVG_LB = (((data$AUTO_AVG_LB/data$AUTO_AR)-1) * 100),
    ES27_AVG_LB = (((data$ES27_AVG_LB/data$AUTO_AR)-1) * 100),
    ES64_AVG_LB = (((data$ES64_AVG_LB/data$AUTO_AR)-1) * 100)    
  ))
}

# Calculate percentage of improvement 
W1_percentage_of_improvement <- calculate_percentage_of_improvement(W1)
W2_percentage_of_improvement <- calculate_percentage_of_improvement(W2)
W3_percentage_of_improvement <- calculate_percentage_of_improvement(W3)
W4_percentage_of_improvement <- calculate_percentage_of_improvement(W4)

head(W1_percentage_of_improvement)
head(W2_percentage_of_improvement)
head(W3_percentage_of_improvement)
head(W4_percentage_of_improvement)
```

Now let's plot histograms of percentage of WIS improvement for each state including mean and standard deviation of percentage of improvement compared to auto_arima (baseline).

```{r}
# List of models names
models_names <-c(names(W1_percentage_of_improvement))

# Create an empty dataframe to store results
summary_impr <- data.frame(WeekAhead = character(), Model = character(), m = numeric(), sd = numeric(), stringsAsFactors = FALSE)

# List of datasets. One dataset for each target week.
datasets_list <- list("1" = W1_percentage_of_improvement, 
                 "2" = W2_percentage_of_improvement, 
                 "3" = W3_percentage_of_improvement, 
                 "4" = W4_percentage_of_improvement)

# Here I have 2 for loops. One take into account the target week and the other the model.
# Loop through target weeks
for (target_week_ in names(datasets_list)) {
  dataset <- datasets_list[[target_week_]]  # Get the dataset based on target week
  # Loop through models
  for (given_model in models_names) {
    data <- dataset[[given_model]]
    mean_val <- mean(data, na.rm = TRUE)
    sd_val <- sd(data, na.rm = TRUE)

    # Append results to dataframe
    summary_impr <- rbind(summary_impr, data.frame(WeekAhead = target_week_, Model = given_model, m = mean_val, sd = sd_val))

    # Generate histogram
    p <- ggplot(dataset, aes(x = .data[[given_model]])) +
      geom_histogram(color = "black", fill = "lightblue", bins = 30, alpha = 0.7) +
      geom_vline(aes(xintercept = mean_val), color = "red", linetype = "dashed", linewidth = 1) +
      geom_vline(aes(xintercept = mean_val - sd_val), color = "blue", linetype = "dotted", linewidth = 1) +
      geom_vline(aes(xintercept = mean_val + sd_val), color = "blue", linetype = "dotted", linewidth = 1) +
      labs(title = paste("Histogram of", given_model, "target week", target_week_),
           x = given_model, 
           y = "Frequency") +
      theme_minimal()

    print(p)  # Display the plot
  }
}

summary_impr$WeekAhead<-as.numeric(summary_impr$WeekAhead)

summary_impr
```

Datasets with differences and Wilcoxon Holm adjusted p-values

```{r}
# 

all_p_values<-rbind(p_values_wk1,p_values_wk2,p_values_wk3,p_values_wk4)

p_values_and_impr <- merge(summary_impr, all_p_values, by = c("WeekAhead", "Model"))

# Create a new column "Model_Type" based on whether "NoLg" is in the Model name
p_values_and_impr$Model_Type <- ifelse(grepl("_LB$", p_values_and_impr$Model), "LB", "no_LB")

# View the updated dataframe
head(p_values_and_impr)
p_values_and_impr
```




```{r}

new_long_data <- summary_impr %>%
  mutate(
    LogBack = grepl("_LB$", Model),
    Family = sub("_.*", "", Model),  # take everything before the first underscore
    Method = sub("^.*?_(AR|ADJ|EPI|AVG|TMP)(_LB)?$", "\\1", Model)
  )

new_long_data <- new_long_data %>%
  mutate(Model = ifelse(Model == "AUTO_AR", "AUTO_AAR", Model))

model <- lm(m ~ Model, data = new_long_data)
summary(model)

model
new_long_data$Model
# Get tidy summary of coefficients
tidy_model <- broom::tidy(model)

# Filter out intercept for clarity if you want
tidy_model_no_intercept <- tidy_model %>% filter(term != "(Intercept)")

# Plot coefficients with 95% confidence intervals
tidy_model_no_intercept <- tidy_model_no_intercept %>%
  mutate(term = forcats::fct_reorder(term, estimate, .desc = TRUE))

# Plot
ggplot(tidy_model_no_intercept, aes(x = term, y = estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = estimate - std.error * 1.96,
                    ymax = estimate + std.error * 1.96),
                width = 0.2) +
  coord_flip() +  # flip for better readability
  labs(
    title = "Effect Size of Model Types on outcome",
    subtitle =  "Estimates relative to baseline (intercept)",
    y = "Estimate",
    x = ""
  ) +
  theme_minimal()

```


```{r}

new_long_data <- summary_impr %>%
  mutate(
    LogBack = grepl("_LB$", Model),
    Type = sub("_.*", "", Model),  # take everything before the first underscore
    Family = sub("^.*?_(AR|ADJ|EPI|AVG|TMP)(_LB)?$", "\\1", Model)
  )

new_long_data <- new_long_data %>%
  mutate(Family = ifelse(Family == "AR", "AAR", Family))

model <- lm(m ~ Type + Family + LogBack, data = new_long_data)
summary(model)

model
new_long_data$Model
# Get tidy summary of coefficients
tidy_model <- broom::tidy(model)

# Filter out intercept for clarity if you want
tidy_model_no_intercept <- tidy_model %>% filter(term != "(Intercept)")

# Plot coefficients with 95% confidence intervals
tidy_model_no_intercept <- tidy_model_no_intercept %>%
  mutate(term = forcats::fct_reorder(term, estimate, .desc = TRUE))

# Plot
effect_size<- ggplot(tidy_model_no_intercept, aes(x = term, y = estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = estimate - std.error * 1.96,
                    ymax = estimate + std.error * 1.96),
                width = 0.2) +
  coord_flip() +  # flip for better readability
  labs(
    title = "Effect size of model type, family and transformation on WIS difference",
    subtitle =  "WIS Difference relative to the AUTO type, ARIMA family and LogBack False (intercept)",
    y = "WIS Difference",
    x = ""
  ) +
  theme_minimal() + theme(plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))

effect_size

ggsave("Fig6.jpg", effect_size, width =10, height =5)

```

Mean difference and standard deviation

```{r}

library(ggplot2)
library(dplyr)
library(forcats)

# Define significance threshold  
alpha <- 0.05   

# Get model order based on WeekAhead == 1  
model_order <- p_values_and_impr %>%
  filter(WeekAhead == 1) %>%
  arrange(desc(m)) %>%
  pull(Model)  # Extract ordered model names

# Prepare data with significance flag and ordering  
p_df <- p_values_and_impr %>%
  mutate(Significance = ifelse(p_values < alpha, "Significant", "Not Significant"),
         Model_Type = ifelse(grepl("_LB$", Model), "With log-back transformation", "Without log-back transformation"),
         Model = factor(Model, levels = model_order))  # Apply ordered factor

# Heatmap plot with models ordered by WeekAhead == 1  
plot_m_heatmap <- ggplot(p_df, aes(x = factor(WeekAhead), y = Model, fill = m)) +
  geom_tile(aes(fill = ifelse(Significance == "Significant", m, NA)), color = "black") +  # Fill only significant ones
  geom_tile(data = p_df %>% filter(Significance == "Not Significant"), 
            aes(x = factor(WeekAhead), y = Model), fill = "gray80", color = "black") +  # Gray for non-significant
  geom_text(aes(label = paste0("m:", round(m, 1),", sd:", round(sd, 1))), 
            color = "black", size = 4) +  # Add text labels
  scale_fill_gradient2(
  low = "cyan", 
  mid = "white", 
  high = "red", 
  midpoint = 0,     # <-- Sets 0 as the midpoint
  na.value = "gray80", 
  name = "Mean difference", 
  limits = c(-35, 35)       
)+
  
  labs(title = "Mean differences between models' WIS and the baseline across 48 states",
       subtitle = "Gray boxes indicate models that are not significantly different from the baseline (p>0.05)",
         caption = "m = mean difference, sd = standard deviation",
       x = "Target Ahead",
       y = "") + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
  plot.caption = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),) +
  facet_wrap(~ Model_Type, scales = "free_y")  # Separate NoLg and other models


# Print plot
print(plot_m_heatmap)
ggsave("Fig5.jpg", plot_m_heatmap, width = 14, height = 7 )

```

Now let's plot a map of percentage of WIS improvement for each state.

```{r}
# MAP 1 week ahead

W1_map <- data.frame(
  STATE = W1$STATE,
  percentage_improvement = W1_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG=W1$AUTO_AVG_LB
)

# Merge the best model data with the states map
W1_map <- states %>%
  left_join(W1_map, by = c("STATE")) %>%
  drop_na()

################################### MAP 2 weeka ahead

W2_map <- data.frame(
  STATE = W2$STATE,
  percentage_improvement = W2_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG=W2$AUTO_AVG_LB
)

# Merge the best model data with the states map
W2_map <- states %>%
  left_join(W2_map, by = c("STATE"))%>%
  drop_na()

##################################### MAP 3 weeka ahead

W3_map <- data.frame(
  STATE = W3$STATE,
  percentage_improvement = W3_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG=W3$AUTO_AVG_LB
)

# Merge the best model data with the states map
W3_map <- states %>%
  left_join(W3_map, by = c("STATE"))%>%
  drop_na() 

############################### MAP 4 weeka ahead

W4_map <- data.frame(
  STATE = W4$STATE,
  percentage_improvement = W4_percentage_of_improvement$AUTO_AVG_LB,
  AUTO_AVG=W4$AUTO_AVG_LB
)

# Merge the best model data with the states map
W4_map <- states %>%
  left_join(W4_map, by = c("STATE"))%>%
  drop_na()
```

Let's plot some maps with the best models in each state and the percentage of improvement compared to the AUTO ARIMA models for the same state.
Here I define some colors categories that I will use on the next maps.

1 week ahead percentage of improvement

```{r}

ES_1WEEK <- ggplot(W1_map) +
  geom_sf(aes(fill = AUTO_AVG)) +  # Fill based on the best model
  scale_fill_gradient2(low = "skyblue", mid = "lightyellow2", high = "red", midpoint = 100, limits = c(0, 352)) +  
  ggtitle("1 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W1_map, aes(label = round(AUTO_AVG,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "mean WIS",  
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range


ES_1WEEK<- ES_1WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_1WEEK
#ggsave(ES_1WEEK, height = 4.5, width = 6.5,  filename="Fig4A.jpg")  
```

2 weeks ahead

```{r}

ES_2WEEK <- ggplot(W2_map) +
  geom_sf(aes(fill = AUTO_AVG)) +  # Fill based on the best model
  scale_fill_gradient2(low = "skyblue", mid = "lightyellow2", high = "red", midpoint = 100, limits = c(0, 352)) +  
  ggtitle("2 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W2_map, aes(label = round(AUTO_AVG,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "mean WIS",
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_2WEEK <-ES_2WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_2WEEK
#ggsave(ES_2WEEK, height = 4.5, width = 6.5,  filename="Fig4B.jpg")  
```

3 weeks ahead

```{r}

ES_3WEEK <- ggplot(W3_map) +
  geom_sf(aes(fill = AUTO_AVG)) +  # Fill based on the best model
  scale_fill_gradient2(low = "skyblue", mid = "lightyellow2", high = "red", midpoint = 100, limits = c(0, 352)) +  
  ggtitle("3 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W3_map, aes(label = round(AUTO_AVG,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "mean WIS",
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_3WEEK<- ES_3WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_3WEEK
#ggsave(ES_3WEEK, height = 4.5, width = 6.5,  filename="Fig4C.jpg")  
```
4 weeks ahead

```{r}

ES_4WEEK <- ggplot(W4_map) +
  geom_sf(aes(fill = AUTO_AVG)) +
  scale_fill_gradient2(low = "skyblue", mid = "lightyellow2", high = "red", 
                       midpoint = 100, limits = c(0, 352)) +  
  ggtitle("4 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W4_map, aes(label = round(AUTO_AVG,0)),  
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +
  labs(
    fill = "mean WIS", 
       x = "",
       y = ""
  )

x_limits <- c(-125, -67)  
y_limits <- c(25, 50)    

ES_4WEEK<-ES_4WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_4WEEK
#ggsave(ES_4WEEK,height = 4.5, width = 6.5,  filename="Fig4D.jpg")  
```

Combine in a 2x2 grid

```{r}
# Combine in a 2x2 grid
combined_plot <- (ES_1WEEK | ES_2WEEK) /
                 (ES_3WEEK | ES_4WEEK) + 
  plot_annotation(
    title = "Mean WIS for the 48 states in the contiguous U.S.",
    subtitle = "Results for the the 2022/2023 and 2023/2024 influenza seasons",
    theme = theme(plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))
  )
# Print
print(combined_plot) 

# Save to file
ggsave("Fig7.jpg", combined_plot, width =12, height =7)

```

Loading datasets for regression analysis

```{r}
pop_data <- read.csv("NHSH_hospitalizations_seed/regression_features/population_data.csv") # resident population and population density
sovi_data <- read.csv("NHSH_hospitalizations_seed/regression_features/sovi_2010.2014.csv") # SOVI index
bric_data<-read.csv("NHSH_hospitalizations_seed/regression_features/bric2015.csv") # BRIC index
humidity_data<-read.csv("NHSH_hospitalizations_seed/regression_features/humidity_climatology_1990_2020.csv") # ERA5 Specific Humidity
temperature_data<-read.csv("NHSH_hospitalizations_seed/regression_features/temperature_climatology_1990_2020.csv") # ERA5 Specific Temperature

```

REGRESSION MODELS

We will run the regression for evaluating if the best model log(WIS) which represent its performance is related to given independent variables.

```{r}

# List of data frames
WIS_dataframes <- list(W1 = W1_map, W2 = W2_map, W3 = W3_map, W4=W4_map)
regression_models<-data.frame()

```

Percentage of AUTO_ADJ mean WIS

AUTO_ADJ WIS x RESIDENT POPULATION 2020

```{r}

for(i in c(1,2,3,4)){

  # Combining data for the same states
  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fitting the regression model
  model <- lm((WIS_pop_data$AUTO_AVG) ~ (WIS_pop_data$Resident_population_2020))
  # View the model summary
  model_summary <- summary(model)
  # Getting the R and p values for the plot
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # Saving the results in a dataframe
  regression_models2 <- data.frame(
    independent_variable = "Resident Population (2020)", 
    Week_Ahead = i, 
    r_squared = r_squared, 
    p_value = p_value
  )
  # Append to the main results dataframe
  regression_models <- rbind(regression_models, regression_models2)
}

regression_models


```

best regression plot

```{r}
plot_list <- list()  # store plots

for(i in 1:4) {
  
  # Combine WIS data and population
  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  
  # Fit linear model
  model <- lm(AUTO_AVG ~ Resident_population_2020, data = WIS_pop_data)
  model_summary <- summary(model)
  
  # Save R and p-values
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  
  # Create plot
  p <- ggplot(WIS_pop_data, aes(x = Resident_population_2020, y = AUTO_AVG)) +
    geom_point(color = "steelblue", size = 2) +
    geom_smooth(method = "lm", se = FALSE, color = "darkred", linetype = "dashed") +
    labs(
      title = paste("Regression","Target Week", i),
      subtitle = paste("R =", r_squared, "| p =", p_value),
      x = "Resident Population (2020)",
      y = "AUTO_AVG"
    ) +
    theme_minimal()
  
  # Store the plot
  plot_list[[i]] <- p
}


# Combine the plots vertically
combined_regressions <- wrap_plots(plot_list, ncol = 1)

# Display (optional)
combined_regressions

# Save the combined plot
#ggsave("Figx.png", combined_plot, width = 3, height = 5, dpi = 600)
```

AUTO_ADJ WIS x POPULATION DENSITY

```{r}

for(i in c(1,2,3,4)){

  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_pop_data$AUTO_AVG) ~ (WIS_pop_data$Population_density_2020))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Population Density (2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # Append to the main results dataframe
  regression_models<-rbind(regression_models,regression_models2)
}

```

Here we will weight the Social Vulnerability Index (SoVI) and Baseline Resilience Indicators for Communities (BRIC) county indexes which for each states based on the population size in each county.

```{r}

#############################################################
# SOVI BY STATE
# weighted by population size in each county
sovi_by_state <- sovi_data %>%
  filter(!is.nan(sovi)) %>%  # Exclude rows where 'sovi' is NaN
  group_by(state.name) %>%
  summarize(weighted_mean = weighted.mean(sovi, w = population.2020, na.rm = TRUE))

colnames(sovi_by_state)[1] <- "STATE"

#############################################################
# BRIC BY STATE
# weighted by population size in each county

bric_by_state <- bric_data %>%
  group_by(state.name) %>%
  summarize(across(16:22, ~ weighted.mean(.x, w = population.2020, na.rm = TRUE), .names = "weighted_mean_{col}"))
colnames(bric_by_state)[1] <- "STATE"

```

AUTO_AVG WIS x SOVI

```{r}

for(i in c(1,2,3,4)){

  WIS_sovi<-NULL
  WIS_sovi <- inner_join(WIS_dataframes[[i]], sovi_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_sovi$AUTO_AVG) ~ (WIS_sovi$weighted_mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Social Vulnerability Index (SoVI)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC SOCIAL

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model  
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.social))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Social (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC ECONOMIC

```{r}
for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.economic))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Economic (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC Infrastructure

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.infrastructure))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Infrastructure (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC institutional

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.institutional))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Institutional (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC community

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[1]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.community))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Community (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC environment

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.environment))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Environment (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC total

```{r}

for(i in 1:4){
  # BRIC INDEX
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$AUTO_AVG) ~ (WIS_bric$weighted_mean_z_bric.total))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC total (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}
```

TEMPERATUE - ERA5

Now we will look at regression models that uses mean temperature and specific humidity.

-------------------

AUTO_AVG WIS x Temperature ERA5 Data

```{r}
for(i in 1:4){
  # TEMPERATURE DATA from ERA5
  WIS_temp <- inner_join(WIS_dataframes[[i]], temperature_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_temp$AUTO_AVG) ~ (WIS_temp$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Temperature (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}
```

AUTO_AVG WIS x Specific Humidity ERA5 Data

```{r}
library(ggpubr)

# regression results 
print(regression_models)

for(i in 1:4){
  # HUMIDITY DATA from ERA5
  WIS_humidity <- inner_join(WIS_dataframes[[i]], humidity_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_humidity$AUTO_AVG) ~ (WIS_humidity$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Specific Humidty (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

# Plot the table
regression_models
```

SUMMARY OF RESULTS 

```{r}
# Define a significance threshold (p < 0.05)
regression_models <- regression_models %>%
  mutate(significance = ifelse(p_value < 0.05, "Significant", "Not Significant"))

# Plot
reg2<-ggplot(regression_models, aes(x = Week_Ahead, y = independent_variable, fill = significance)) +  
  geom_tile(color = "black") +  # Add black borders to squares
  geom_text(aes(label = round(r_squared, 3)), color = "black", size = 6) +  # Text inside boxes
  scale_fill_manual(values = c("Significant" = "cyan", "Not Significant" = "gray")) +  
  labs(title = "Regression models R",
       subtitle = "Mean WIS as dependent variable",
       x = "Target Week",
       y = "Independent Variables",
       fill = "Significance (p < 0.05)") +  
  theme_minimal() +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))

reg2

# Combine the plots vertically
reg2_scatter <- reg2 | combined_regressions 
reg2_scatter
ggsave(reg2_scatter, height = 6, width = 12, filename="Fig8.jpg")  
#ggsave(reg2, filename="reg2.jpg",height = 8, width = 10)
```


Let's plot some maps with the with the mean (%) of difference between the AUTO_AVG and the AUTO ARIMA models for the same state.

1 week ahead percentage of improvement

```{r}

ES_1WEEK <- ggplot(W1_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("1 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W1_map, aes(label = round(percentage_improvement,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_1WEEK<-ES_1WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

#ggsave(ES_1WEEK,height = 4.5, width = 6.5,  filename="Fig5A.jpg")  
```
2 weeks ahead

```{r}

ES_2WEEK <- ggplot(W2_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("2 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W2_map, aes(label = round(percentage_improvement,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle


x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_2WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

#ggsave(ES_2WEEK, height = 4.5, width = 6.5, filename="Fig5B.jpg")  
```

3 weeks ahead

```{r}

ES_3WEEK <- ggplot(W3_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("3 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W3_map, aes(label = round(percentage_improvement,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill =  "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_3WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

#ggsave(ES_3WEEK, height = 4.5, width = 6.5, filename="Fig5C.jpg")  
```
4 weeks ahead

```{r}
ES_4WEEK <- ggplot(W4_map) +
  geom_sf(aes(fill = percentage_improvement)) +  # Fill based on the best model
  scale_fill_gradient2(low ="skyblue" , mid = "lightyellow", high = "darkred", midpoint = 0, limits = c(-60, 30)) +  
  ggtitle("4 weeks ahead") +
  theme_light() +
  theme(legend.position = "right",
    plot.title = element_text(hjust = 0.5)) +
  geom_sf_text(data = W4_map, aes(label = round(percentage_improvement,0)),  # Round to whole numbers
               size = 3,
               color = "black",
               check_overlap = TRUE,fontface = "bold") +  # Display percentage improvement in each state
  labs(
    fill = "Mean difference",  # Label for the legend
       x = "",
       y = ""
  )  # Adding a subtitle

x_limits <- c(-125, -67)  # Set the desired longitude range
y_limits <- c(25, 50)    # Set the desired latitude range

ES_4WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

#ggsave(ES_4WEEK, height = 4.5, width = 6.5,  filename="Fig5D.jpg")  
```

```{r}
# Ensure each plot has coord_sf applied
ES_1WEEK <- ES_1WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_2WEEK <- ES_2WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_3WEEK <- ES_3WEEK + coord_sf(xlim = x_limits, ylim = y_limits)
ES_4WEEK <- ES_4WEEK + coord_sf(xlim = x_limits, ylim = y_limits)

# Combine in a 2x2 grid
combined_plot <- (ES_1WEEK | ES_2WEEK) /
                 (ES_3WEEK | ES_4WEEK) + 
  plot_annotation(
    title = "Mean WIS differences compared to the baseline",
    subtitle = "Results by forecast horizon",
    theme = theme(plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))
  )
# Print
print(combined_plot) 

# Save to file
ggsave("Fig9.jpg", combined_plot, width =12, height =7)
```

REGRESSION MODELS

We will run the regression for evaluating if the best model log(WIS) which represent its performance is related to given independent variables.

```{r}

# List of data frames
WIS_dataframes <- list(W1 = W1_map, W2 = W2_map, W3 = W3_map, W4=W4_map)
regression_models<-data.frame()

```

Percentage of improvement regression analysis

AUTO_AVG WIS x RESIDENT POPULATION 2020

```{r}

for(i in c(1,2,3,4)){

  # Combining data for the same states
  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fitting the regression model
  model <- lm((WIS_pop_data$percentage_improvement) ~ (WIS_pop_data$Resident_population_2020))
  # View the model summary
  model_summary <- summary(model)
  # Getting the R and p values for the plot
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # Saving the results in a dataframe
  regression_models2 <- data.frame(
    independent_variable = "Resident Population (2020)", 
    Week_Ahead = i, 
    r_squared = r_squared, 
    p_value = p_value
  )
  # Append to the main results dataframe
  regression_models <- rbind(regression_models, regression_models2)
}

regression_models
```

AUTO_AVG WIS x POPULATION DENSITY

```{r}

for(i in c(1,2,3,4)){

  WIS_pop_data <- inner_join(WIS_dataframes[[i]], pop_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_pop_data$percentage_improvement) ~ (WIS_pop_data$Population_density_2020))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Population Density (2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # Append to the main results dataframe
  regression_models<-rbind(regression_models,regression_models2)
}

```

Here we will weight the Social Vulnerability Index (SoVI) and Baseline Resilience Indicators for Communities (BRIC) county indexes which for each states based on the population size in each county.

```{r}
#############################################################
# SOVI BY STATE
# weighted by population size in each county
sovi_by_state <- sovi_data %>%
  filter(!is.nan(sovi)) %>%  # Exclude rows where 'sovi' is NaN
  group_by(state.name) %>%
  summarize(weighted_mean = weighted.mean(sovi, w = population.2020, na.rm = TRUE))

colnames(sovi_by_state)[1] <- "STATE"

#############################################################
# BRIC BY STATE
# weighted by population size in each county

bric_by_state <- bric_data %>%
  group_by(state.name) %>%
  summarize(across(16:22, ~ weighted.mean(.x, w = population.2020, na.rm = TRUE), .names = "weighted_mean_{col}"))
colnames(bric_by_state)[1] <- "STATE"

```

AUTO_AVG WIS x SOVI

```{r}

for(i in c(1,2,3,4)){

  WIS_sovi<-NULL
  WIS_sovi <- inner_join(WIS_dataframes[[i]], sovi_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_sovi$percentage_improvement) ~ (WIS_sovi$weighted_mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Social Vulnerability Index (SoVI)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC SOCIAL

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model  
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.social))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Social (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending the results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC ECONOMIC

```{r}
for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.economic))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Economic (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC Infrastructure

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.infrastructure))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Infrastructure (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```


best regression plot

```{r}

# Prepare a list to hold your plots
bric_plots <- list()

for (i in 1:4) {
  # 1) Join the WIS and BRIC data
  WIS_bric <- inner_join(
    WIS_dataframes[[i]],
    bric_by_state,
    by = "STATE"
  )
  
  # 2) Fit the linear model
  model <- lm(
    percentage_improvement ~ weighted_mean_z_bric.infrastructure,
    data = WIS_bric
  )
  ms <- summary(model)
  
  # 3) Extract R and pvalue
  r2 <- round(ms$r.squared, 3)
  p  <- signif(ms$coefficients[2, 4], 3)
  
  # 4) Build the ggplot
  p <- ggplot(WIS_bric,
              aes(x = weighted_mean_z_bric.infrastructure,
                  y = percentage_improvement)) +
    geom_point(color = "steelblue", size = 2) +
    geom_smooth(method = "lm", se = FALSE, color = "darkred") +
    labs(
      title    = paste("Regression","Target Week", i),
      subtitle = paste0("R = ", r2, "   p = ", p),
      x        = "BRIC infrastructure (2015)",
      y        = "Difference"
    ) +
    theme_minimal()
  
  # 5) Store it
  bric_plots[[i]] <- p
}

# Combine the plots vertically
combined_regressions <- wrap_plots(bric_plots, ncol = 1)

# Display 
combined_regressions

```

AUTO_AVG WIS x BRIC institutional

```{r}

for (i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.institutional))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Institutional (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC community

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[1]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.community))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Community (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC environment

```{r}

for(i in 1:4){
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.environment))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC Environment (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}

```

AUTO_AVG WIS x BRIC total

```{r}

for(i in 1:4){
  # BRIC INDEX
  WIS_bric <- inner_join(WIS_dataframes[[i]], bric_by_state, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_bric$percentage_improvement) ~ (WIS_bric$weighted_mean_z_bric.total))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="BRIC total (2015)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  regression_models<-rbind(regression_models,regression_models2)
}
```

TEMPERATUE - ERA5

Now we will look at regression models that uses mean temperature and specific humidity.

-------------------

AUTO_AVG WIS x Temperature ERA5 Data

```{r}


for(i in 1:4){
  # TEMPERATURE DATA from ERA5
  WIS_temp <- inner_join(WIS_dataframes[[i]], temperature_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_temp$percentage_improvement) ~ (WIS_temp$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Temperature (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}
```

AUTO_AVG WIS x Specific Humidity ERA5 Data

```{r}

# regression results 
print(regression_models)

for(i in 1:4){
  # HUMIDITY DATA from ERA5
  WIS_humidity <- inner_join(WIS_dataframes[[i]], humidity_data, by = "STATE")
  # Fit the regression model
  model <- lm((WIS_humidity$percentage_improvement) ~ (WIS_humidity$mean))
  # View the model summary
  model_summary <- summary(model)
  # Extract R-squared and p-value
  r_squared <- round(model_summary$r.squared, 3)
  p_value <- signif(model_summary$coefficients[2, 4], 3)
  # saving the results in a dataframe
  regression_models2<-data.frame("independent_variable"="Mean Specific Humidty (1990-2020)","Week_Ahead"=i, "r_squared"=r_squared,"p_value"= p_value)
  # appending results
  regression_models<-rbind(regression_models,regression_models2)
}

# Plot the table
regression_models
```

SUMMARY OF RESULTS 

```{r}
# Define a significance threshold (p < 0.05)
regression_models <- regression_models %>%
  mutate(significance = ifelse(p_value < 0.05, "Significant", "Not Significant"))

# Plot
reg2<-ggplot(regression_models, aes(x = Week_Ahead, y = independent_variable, fill = significance)) +  
  geom_tile(color = "black") +  # Add black borders to squares
  geom_text(aes(label = round(r_squared, 3)), color = "black", size = 6) +  # Text inside boxes
  scale_fill_manual(values = c("Significant" = "cyan", "Not Significant" = "gray")) +  
  labs(title = "Regression models R",
       subtitle = "Mean WIS differences as dependent variable",
       x = "Target Week",
       y = "Independent Variables",
       fill = "Significance (p < 0.05)") +    
  theme_minimal() +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text.y = element_text(size = 10),
        plot.title = element_text(size = 16, face = "bold"),
                  plot.subtitle = element_text(size = 14))

reg2

reg2_scatter <- reg2 | combined_regressions 
reg2_scatter
ggsave(reg2_scatter, height = 6, width = 12, filename="Fig10.jpg")  
#ggsave(reg2, filename="Fig9.jpg",height = 6, width = 8)
```

```{r}
# Create a list of data frames for the four weeks
weeks <- 1:4
summed_data_list <- list()

for (week in weeks) {
  # Merge the data frames for the current week
  data__ <- merge(get(paste0("filtered_df_W", week, "_NoLg")),
                  get(paste0("filtered_df_W", week)))
  
  # Sum values by Julian date across all states
  summed_data <- data__ %>%
    group_by(Julian_date) %>%
    summarize(
      AUTO_AR = mean(AUTO_AR, na.rm = TRUE),  # Sum across all states
      AUTO_AVG_LB = mean(AUTO_AVG_LB, na.rm = TRUE)           # Sum across all states
    ) %>%
    # Calculate the difference ratio
    mutate(Difference =  ((AUTO_AVG_LB / AUTO_AR)-1)*100,
           Week = paste0("Week ", week))
  
  # Store the summarized data in the list
  summed_data_list[[week]] <- summed_data
}

# Combine all weeks into a single data frame
summed_data_all <- bind_rows(summed_data_list)

# Plot the difference using ggplot2
model_improv<-ggplot(summed_data_all, aes(x = Julian_date, y = (Difference), color = Week)) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 0, color = "black", linetype = "dashed", size = 0.8) +
  theme_minimal() +
  labs(
    title = "A) Weekly mean WIS differences across all states",
    subtitle = "AUTO_AVG_LB compared to baseline",
    x = "",
    y = "Mean difference"
  ) +
  scale_y_continuous(
    limits = c(-100, 100),
    breaks = seq(-100, 100, by = 20)
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %y"
  ) +
scale_color_manual(
  values = c(
    "Week 1" = "#4575B4",  # Blue
    "Week 2" = "#91BFDB",  # Light blue
    "Week 3" = "#E89C9C",  # Light red
    "Week 4" = "#D73027"   # Red
  )
) +
  theme(
    plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

model_improv

#ggsave(model_improv, height = 4.5, width = 9,  filename="Fig10.jpg")  
```
hospitalizations

```{r}

total_hospitalizations_by_week <- AUTO_ADJACENT_WEEK1 %>%
  filter(epiweek >= 40 | epiweek <= 20) %>%  # Apply filter AFTER epiweek exists
  group_by(target_end_date) %>%
  summarise(mean_cases = sum(cases, na.rm = TRUE))

hospital_plot <-ggplot(total_hospitalizations_by_week, aes(x = target_end_date, y = mean_cases)) +
  geom_bar(stat = "identity",fill = "steelblue") +
  labs(title = "B) Total influenza hospitalizations on the 48 states",
       x = "",
       y = "Influenza hospitalizations") +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %y"
  ) +
  theme_minimal()+
  theme(plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 14),
    axis.text.x = element_text(angle = 45, hjust = 1))

hospital_plot

```


```{r}

# Combine the plots vertically
combined_plot <-  model_improv /hospital_plot 

# Display (optional)
combined_plot

# Save the combined plot
ggsave("Fig11.jpg", combined_plot, width = 7, height = 7, dpi = 600)

```